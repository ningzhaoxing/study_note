# 1. 调度器设计策略

## 1.1 work stealing 机制
当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

## 1.2 hand off 机制
当当前线程进行系统调用时而导致阻塞，线程会释放绑定的 p，把 p 转移到其他空闲的线程运行。

具体体现在：
- 抢占：go 中一个 goroutine 最多占用 cpu 10ms，防止其他 goroutine 饿死。此时线程会释放绑定的 p，把 p 转移到其他空闲线程去运行。
- 限制并发，利用并行：
	- 在执行 cpu 密集型任务时，尽量让 cpu 发挥出最大性能，可以将 `GOMAXPROCS` 设置为 cpu 核数或者稍大一些
	- 在执行 io 密集型任务时，可以将 `GOMAXPROCS` 设置小一些，减少 io 资源的排队竞争
	- 在单核心 CPU 上，`GOMAXPROCS` 设为 1 即可（再多也无法并行，只会增加切换成本）
## 1.3 阻塞处理机制

1. 如果 g 因为系统调用（I/O 操作）发生阻塞，则 M 会被挂起，并释放当前绑定的 P，P 寻找新的空闲的 M 继续工作。当这个系统调用执行完成后，M 会重新获取一个 P，若能获取到则继续执行原来的 G；若暂时获取不到，则会将 G 放入全局队列，M 进入空闲状态。
2. 如果 g 因为其他阻塞（如锁、channel 等待）阻塞时，G 会被挂起，P 继续调度其他 G 进行执行。当 G 的阻塞操作结束时，会将其加入到本地队列或全局队列。

## 1.4 61次调度机制

为什么要设置61次？
为了解决全局队列中的 g 的全局饥饿问题，同时减少检查全局队列的锁竞争问题，

1.  每个 p 会维护一个计数器，每次调度本地队列的 g 计数器都会加一。当计数器达到  61 次时，会从全局队列中取最多一半 g 放入到本地队列。

## 1.5 全局队列的 G 都有哪些情况

1. 被系统调用、（锁、channel）等阻塞后恢复待执行的 g
2. p 的本地队列放不下的 g
3. 通过 go 关键字创建的 g


# 2. 设计目标

## 2.1 公平性

定期到全局队列中检查，确保全局队列中的 `goroutine` 不会完全饥饿。

## 2.2 负载均衡

通过 work-stealing 机制，平衡不同 P 之间的负载

## 2.3 低延迟

通过 work-stealing 机制和定期到全局队列中检查，减少锁竞争；同时优先从本地队列中取 G 是无锁高效的方式。