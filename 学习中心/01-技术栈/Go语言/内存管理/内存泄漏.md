本质上就是不再使用的内存没有被 GC 回收，导致进程占用内存持续增长。

# 1. 场景

## 1.1 goroutine 泄漏

### 1.1.1 goroutine 陷入无限循环

没有推出条件的循环会让 goroutine 永远运行，起占用内存永远不会释放

```go
func main() {
	go func() {
		for {
			// 无推出逻辑
		}
	}
}
```

### 1.1.2 channel 操作阻塞

- 向无缓冲的 channel 中写数据，但无人接收，goroutine 会永久阻塞。
- 向 channel 中读数据，但没有人写数据
- 关闭 channel 后进行操作会发生 panic

```go
func leak() {
	ch := make(chan int)
	go func() {
		ch <- 1
	}
	
	// 没有接收 ch 的协程，上面的 goroutine 会永久阻塞
}
```

### 1.1.3 等待组（sync.WaitGroup）未正确释放

调用 `wg.Add(n)` 后，未调用足够的 `wg.Done()`，导致 `wg.Wait()` 永久阻塞，关联的 `goroutine` 永久阻塞。

```go
func leak() {
	var wg sync.WaitGroup
	wg.Add(1)
	
	go func() {
		// 忘记 wg.Done()
	}
	
	wg.Wait()
}
```

### 1.1.4 锁未及时释放

`sync.Mutex` 加锁有未解锁，导致永久等待锁，`goroutine` 泄漏。

```go
func leak() {
	var mx sync.Mutex
	
	go func() {
		mx.Lock()
		// 业务逻辑结束后，忘记 UnLokc()
	}
	
}
```

## 1.2 未释放资源引用

gc 会回收“不可达”的内存，但如果变量被长期存活的对象（如全局变量）引用，即使不再使用，也不会被回收。

### 1.2.1 全局集合（map、slice 等）未清理

全局 map 只添加不删除，map 越来越大，内存无法释放

```go
var golbalMap = make(map[int]string)

func addData(id int, value string) {
	golbalMap[id] = value
}
```

### 1.2.2 闭包

闭包如果被长期持有，会间接引用外部变量，导致这些变量无法被回收。

```go

// 调用后，回调函数被长期保存，导致 num 无法被回收
var callBack = leak()

func leak() func() {
	num := 0
	return func() {
		// 闭包未使用 num，但仍持有其引用
		fmt.Println("hello")
	}
}

// 解决方案
func leak() func() {
	{
		num := 0
	}  // 单独定义代码块，脱离作用域
	return func() {
		// 闭包未使用 num，但仍持有其引用
		fmt.Println("hello")
	}
}
```


# 2. 如何排查内存泄漏

使用官方工具。
- `go test -benchmen`：基准测试时查看内存分配和泄漏情况
- `pprof`：通过 `net/http/pprof` 采集内存快照（`heap` 类型），分析内存增长的对象类型和调用栈