---

mindmap-plugin: basic

---

# mq

## 基础
- 消费模型
	- 队列模型 p2p
		- 一个队列可以有多个生产者生产消息；也可以有多个消费者消费消息，消费者之间为竞争关系
		- 新节点
	- 消息订阅模型
- 消费模式
	- 集群消费
		- 一个消费者组共同消费一个主题的多个队列，一个队列只会被消费者组的一个消费者消费
	- 广播消费

## 使用场景
- 解耦
	- 当多系统之间的操作不需要同步时，可以使用 mq 进行解耦。即便一个系统挂了，也不会影响到其他系统。
- 异步
	- 需要提高系统访问速度，可以将不需要同步操作的步骤放到 mq 中 异步操作
- 削峰
	- 一个系统的访问流量有高峰和低峰。高峰时可以将大量消息放在 mq，系统按最大的能力去消费。

## 业务问题
- 幂等写的保证
	- 唯一标识（幂等键）
	- 数据库事务 + 乐观锁
		- 通过版本号或状态字段控制并发更新，确保多次相同消息消费更新等同于单次操作。适用于数据库更新记录（如 余额扣减、订单状态变更）
	- 数据库唯一约束
		- 利用数据库唯一索引防止重复数据写入，适用于数据插入场景（如 订单创建）
	- 分布式锁
		- 通过锁机制保证同一时刻仅有一个请求执行关键操作。适用高并发下的资源抢夺（如 秒杀）
	- 消息去重
		- 生产者为每条消息生成唯一消息ID。消费者在处理消息前，检查该消息 ID 是否处理过，如果已处理则丢弃消息，并返回 ack
- 消息积压问题
	- 问题原因
		- 先排查是否是 bug 原因造成
	- 如何处理
		- 不是 bug
			- 优化消费逻辑。比如是否可以将一条条处理，改为批量处理消息
			- 水平扩容，增加 Topic 的队列数和消费组机器数量，提高整体消费能力
		- 是 bug
			- 先修复消费者的问题
			- 对原来的 topic 扩容10倍
			- 写一个临时的分发数据的 consumer 程序，部署上去消费积压数据，并将这些数据均匀轮询写入临时建立好的10被数量的 queue
			- 接着临时征用 10 倍机器部署 consumer 进行消费。相当于以正常的 10 倍速度来消费数据
			- 等消费完积压数据后，恢复原有架构
- 如何保证数据一致性
	- 触发场景
		- 上游服务创建订单成功后，然后消息没有成功发送出去，下游系统无法感知这件事，导致数据不一样
	- 解决方案
		- 事务消息
			- 生产者先发送半事务消息到 mq，然后执行本地事务，执行成功后 commit 执行结果到 mq，否则 rollback。同时 mq 长时间没有收到生产者的 commit 或 rollback 会反查生产者，根据查询结果执行最终状态。

## 原理
- 可靠性和顺序性如何保证
	- 可靠性保证
		- 消息持久化
		- 消息确认机制
			- 消费者在成功处理完消息后，应该向消息队列发送 ack。队列接收到 ack 后才会移除该消息，否则将继续推送该消息
		- 消息重试策略
			- 消费者处理消息失败后，有合理的重试策略。如果重试失败次数到达一定数量，则可以发送到死信队列，便于人工排查
	- 顺序性保证
		- 有序消息处理场景识别
			- 同一用户的转账记录
			- 同一订单的“创建-支付-发货”状态变更
		- 消息队列对顺序性的支持
		- 消费者顺序处理策略
			- 消费者处理顺序消息时，避免并发处理导致的顺序打情况
				- 单线程
				- 线程池 + 对顺序消息进行串行化处理
- 消息重复消费怎么解决
	- 生产端
		- 中间件提供幂等性发送消息的接口。通过存储msg_id，给生产端提供一个幂等性的发送消息接口
	- 消费端
		- 业务自行处理。对于已成功消费的消息，本地数据库或redis缓存业务唯一标识，每次处理前先进行幂等性校验
- 消息丢失怎么解决
	- 消息生产阶段
		- 生产者处理好返回值和异常，如果返回异常则进行消息重发
	- 消息存储阶段
		- 集群部署。队列中间件通常会写多个节点，即便有一个节点挂了，也能保证数据不丢失
	- 消息消费阶段
		- 保证接收消息+消息处理后再 ack

## 设计思想
- 设计模式
	- 生产者-消费者模式（核心骨架）
		- 通过一个缓冲区来解耦生产者和消费者，让他们不必直接通信，也不必相互等待。解决生产数据和消费数据速度不匹配的问题。
		- 生产者
		- 消费者
		- 缓冲区：消息队列本身
	- 观察者模式/发布-订阅模式（核心通信模型）
		- 发布-订阅模型是观察者模式思想在分布式系统中的具体实现
		- 主题：在消息队列中被称为 Topic 或 Exchange
		- 观察者：订阅了该 Topic 的多个消费者
	- 中介者模式
		- 通过中介者，使各对象之间无需显示地相互引用就可以通信。从而使其耦合松散
	- 队列模式
		- 保证消息的顺序性（在单个队列或分区内）
	- 异步模式
		- 解耦
		- 削峰填谷。生产者无需关注消费者的消费速率，将消息灌注入队列；消费者无需关心生产速率，只复杂最大速率消费队列中的消息
- 设计架构

## kafka 与 rocketmq 对比
- kafka 吞吐量和性能极高， 但可能造成数据丢失（因为不是直接写入磁盘，而是先写入磁盘缓冲区），且只支持简单的收发消息，高级功能基本没有
- rocketmq 只能功能较多（延时队列、消息事务等），但性能相比 kafka 要弱一些