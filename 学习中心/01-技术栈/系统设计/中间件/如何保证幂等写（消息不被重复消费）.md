同一操作的多次执行对系统状态的影响与一次执行结果一致。

# 1. 消息投递的几种语义
## 1.1 最多一次

消息在传递时，最多会被送达一次。可能会出现消息丢失，但不会出现消息重复的情况。
可以用于日志、 监控信息等。

## 1.2 至少一次

消息在传递时，最少会被送达一次。消息一定不会丢，可能会出现重复消息。

绝大部分应用中，都是使用 At Least Once，MQ 都支持该级别

## 1.3 恰好一次

每条消息肯定都会被传输一次且仅传输一次，并保证送达。因为涉及发送端和生产端的协调，通用的【恰好一次】方案，几乎不可能实现。

如何解决幂等性问题？【至少一次】+ 幂等消费 = 【恰好一次】
# 2. 幂等设计方案
## 2.1 利用数据库的唯一约束实现幂等性（日志表联合主键）

比如说转账操作，将账户X 的余额加100元，此时是不幂等的。

因此可以限定对于每个转账单每个账户只可以执行一次。可以建立一个日志表（转账流水表）：转账单ID、账户ID、变更金额。然后设置联合主键（转账单ID、账户ID、变更金额）。

优点：
- 实现简单，利用数据库重复插入自动抛出异常，天然原子性，无并发问题
- 数据可追溯，本身可以作为业务日志，方便后续问题排查和对账

缺点：
- 侵入业务表设计，需要额外创建日志表，或在原有表中添加联合主键字段，增加存储成本
- 仅适用于 “有明确唯一标识组合” 的场景（如转账ID+账户ID）
- 要保证联合主键字段不会在生产消息后，被其他线程修改，导致正常消息的消费失败

## 2.2 为更新的数据设置前置条件（乐观锁）

比如将账户X 的余额增加 100 元，增加一个前置条件：如果账户X 的余额是250元，才执行将余额增加100 元。
在消息队列中应用，在生产者端生产消息时在消息体带上余额。

通用解决方案 **（乐观锁）**：给数据增加一个版本号的属性，在表中添加一个版本号的列，每次更新前，比较当前数据的版本号和消息中的版本号是否一致，如果一致则更新；如果不一致则拒绝更新数据，更新数据的同时将版本号+1，实现幂等设计。


优点：
- 灵活性好，无需额外表结构和联合主键索引
- 性能好，通过乐观锁的方式实现操作，无锁执行效率更高

缺点：
- 只将余额作为前置条件，可能存在 ABA 问题，所以要引入自增版本号
- 存在并发问题导致正常消息被拒绝

## 2.3 记录并检查操作（全局唯一消息ID + 事务）

在执行数据更新操作前，先检查是否执行过这个更新操作。

在生产消息前，生成一个全局唯一的消息ID，消费时先检查这个ID的消息是否被消费过，如果没有被消费才更新数据，然后将消息置为已消费。

需要执行的以下三个操作：
- 检查消费状态
- 更新数据
- 设置消费状态

这三个操作有并发安全问题，因此要保证这三个操作的原子性。-- 可以用事务解决。

优点：
- 通用性强，只要能生成全局唯一消息 ID （如雪花算法 ID）

缺点：
- 需保证“查状态 - 更数据 - 改状态”原子性，依赖数据库事务甚至分布式事务，实现成本高
- 性能损耗大，每次消费需额外执行“查状态 - 改状态”，增加数据库读写压力，高并发会变成瓶颈
- 若事务未提交，可能导致数据已更新但状态未改