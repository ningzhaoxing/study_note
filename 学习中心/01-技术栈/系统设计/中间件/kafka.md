# 1. 基本使用

核心概念：
- **Conn**：这是 kafka 和 broker 之间的连接，可以通过 `Conn` 发送和消费消息
- **Writer**：生产者，用于生产消息，同时可以配置生产消息的模式、Topic、是否自动创建 Topic、负载均衡策略等
- **Reader**：消费者，用于消费消息。同时可以配置消费者组、分区以及自动提交时间间隔

## Conn


## Writer

配置项：
```go
&kafka.Writer{
    Addr:                   kafka.TCP("localhost:9092", "localhost:9093", "localhost:9094"),
    Balancer:               &kafka.LeastBytes{},
    Async:                  true,
    RequiredAcks:           kafka.RequireAll,
    AllowAutoTopicCreation: true,
  }
```

1. 生产者异步发送消息：即生产者将消息发送后，返回空，并直接进入之后的业务逻辑。如果发生消费失败，则 kafka 会进行重试，如果超过重试次数，则会将 *异常消息和错误* 注册到回调函数中。


## Reader

配置项：
```go
kafka.NewReader(kafka.ReaderConfig{
        Brokers:        []string{"localhost:9092", "localhost:9093", "localhost:9094"},
        Topic:          "topic-A",
        GroupID:        "consumer-group-id",
        Partition:      0,
        CommitInterval: time.Second * 1,    // 自定义提交时间间隔
    })
```

# 2. 底层架构实现

## 消费者模型

### 推送模型（push）

即让消费者代理去将消息推送给消费者（Broker -> Consumer）。

缺点：
- 需要消费者代理去记录所有的消费状态（每个消费者的消费状态和进度）
- push 模式很难适应不同消费速率的消费者
- 消息发送速率由 broker 决定，push 模式的目标是尽可能快地速度传递消息，导致 consumer 来不及处理消息

### 拉取模型（pull） - kafka

kafka 采用拉取模型，消费者自己记录消费状态和进度。每个消费者互相独立地顺序拉取每个分区的消息。

优点：
- 消费者可以按照自己的速率去消费
- 且消费进度由消费者独立管理，可以为消费者设置所需要的 offset
缺点：
- 如果 kafka 没消息，消费者会一直陷入循环读取。但消费者可以设置 `readTimeout` ，如果没有消息可供消费，则会等待 `readTimeout` 再返回。

## 消费者组

由一个或多个消费者可以组成一个消费者组，一个消费者组共同消费一个 Topic。
每个分区，在同一时间只能由 gruop 中的一个消费者读取。但多个 group 可以同时消费这个 partition。

优点：
- 消费者可以水平扩展地同时读取大量消息
- 如果一个消费者宕机了，消费者组的其他成员会自动负载均衡地读取之前宕机消费者所拥有的分区

# 3. 消息问题处理

## 3.1如何保证顺序读取消息

kafka 可以保证在同一分区内消息的有序性。

所以，要在 kafka 中保证顺序读取消息，则需要结合生产者、消费者的配置来实现。
1. 生产者端保证消息顺序生产：需要将消息生产至 **指定分区**，可以通过为消息指定相同的 `key` 保证相同 `key` 的消息发送至同一分区。
2. 消费者端保证顺序消费：需要单线程消费同一分区的消息。

kafka 本身无法保证跨分区的消息顺序性，如需要全局消息顺序性，通常有两种方法：
1. 只使用一个分区：将所有消息都写入到同一个分区。
2. 业务层面保证：对消息进行编号或添加时间戳，消费者在读取到消息后，按照标识对消息进行排序消费

## 3.2 kafka 消息积压怎么办

两种情况：第一种是消费者消费能力弱（可能是消费者少或消费者处理的业务逻辑复杂需要优化）；另一种是消费者消费能力强，但是分区少。因为每个分区只能被一个消费者拥有，导致大量消费者性能无法发挥。
所以，针对这两种情况有以下两种解决方案：

1. 增加消费者实例提高消费速率
2. 增加 kafka Topic 的分区数量，以提高消费者并行处理消息的能力

## 3.3 Kafka 为什么一个分区只能由消费者组一个消费者的消费？

如果同一个消费者组的两个消费者可以负责同一分区，会造成很多消息重复现象，且无法保证消息消费的顺序。

