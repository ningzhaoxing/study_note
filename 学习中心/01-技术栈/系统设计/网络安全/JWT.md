# JWT定义

JWT是JSON Web Token的缩写。是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准(RFC 7519),该token被设计为紧凑且安全的，特别适用于**分布式站点的单点登录(SSO)场景。

JWT的声明一般被用来在身份提供者和服务提供者间传递被**认证的用户身份信息**，以便从资源服务器获取资源，也可以增加一些额外的其他业务逻辑所必须的是个声明信息。
该token可直接被用于认证，也可被加密。

> 简单来说，JWT是一种基于JSON的用于身份验证和传递信息的开发标准。

## JWT的适用场景
- 授权
	解决**单点登录**问题。
- 信息交换
	JWT是在各个服务之间安全传输信息的好方法。这是因为JWT可以**签名**。例如使用公钥/私钥对儿 - 确定请求方是合法的。
	此外，由于使用**标头和有效负载**计算**签名**，还可以验证内容**是否未被篡改**。

# 跨域认证问题

> 也就是为什么要使用JWT？

互联网服务离不开用户认证。一般流程是下面这样： 
```go
1、用户向服务器发送用户名和密码。 
2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 
3、服务器向用户返回一个 session_id，写入用户的 Cookie。 
4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 
5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。
```

> 这种模式的问题在于，扩展性不好。
> 如果是分布式服务器集群，就要求各服务器之间 session 数据共享，每台服务器都能读取 session

针对此问题，有两种解决方案：
1. 使 `session` 数据可持久化，写入到数据库或别的持久层。但缺点是工程量较大。
2. 使用JWT。将所有数据都保存在客户端，每次请求都将数据返回给服务器。

# JWT的认证流程
![[20250118103909.png]]

```go
1，浏览器发起请求登陆，携带用户名和密码； 
2，服务端验证身份，根据算法，将用户标识符打包生成 token, 
3，服务器返回JWT信息给浏览器，JWT不包含敏感信息； 
4，浏览器发起请求获取用户资料，把刚刚拿到的 token一起发送给服务器； 
5，服务器发现数据中有 token，验明正身； 
6，服务器返回该用户的用户资料；
```
# JWT的数据结构
本质上是一个 JSON 对象

## JWT消息构成

一个token分为三部分
- 头部 header
- 载荷 payload
- 签证 signature
这三部分分别用"."分隔为三个子串。一般格式为: `xxxxx.yyyyy.zzzzz
`
![[20250118105049.png]]

### 头部 header
header 部分是一个JSON对象

JWT的头部承载两部分信息:
- 声明类型，这里是JWT
- 声明加密的算法，通常直接使用 HMAC SHA256
```GO
JWT的头部描述JWT元数据的JSON对象参考： 
{ 
	"alg": "HS256", 
	"typ": "JWT" 
}
```
### 载荷 payload
Payload 部分也是一个JSON对象，用来存放实际需要传递的数据。以下是7个官方字段:

> iss (issuer)：签发人 
> exp (expiration time)：过期时间 
> sub (subject)：主题 
> aud (audience)：受众 
> nbf (Not Before)：生效时间 
> iat (Issued At)：签发时间 
> jti (JWT ID)：编号

除此之外，我们可以将需要传递的信息，自定义为私有字段放在 载荷 部分。

### 签名 signature
Signature 部分是对前两部分的签名，防止数据篡改。

首先，需要指定一个只有服务器才知道的密钥(secret)。
然后，使用 Header 中指定的签名算法(默认HMAC SHA256)，按照下面公式产生签名

> HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

# JWT 的基本用法

客户端收到服务器返回的 JWT， 将其存储在 Cookie 或 localStorage 中。
此后，客户端发起请求都会带JWT。
如果存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header首部的 Authorization 字段中。
`Authorization: Bearer <token>`


# JWT的加密过程

1. 用户登录成功后，服务端会使用JWT生成一个token，并返回给用户
```go
 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9  //第一段 header
.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ //第二段 payload
.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c //第三段 signature
```
2. `header`由下面的JSON对象通过 base64(可逆) 加密算法得到
```go
{
  "alg": "HS256",   //第三段字符串的不可逆加密类型HS256
  "typ": "JWT"   //token类型JWT
}
```
3. `payload`由下面的JSON对象通过 base64(可逆) 加密算法得到
```go
// payload信息 为自定义值，一般不放敏感信息
{
  "sub": "1234567890",   //用户id
  "name": "John Doe",		//用户名
  "exp": 1516239022		//token过期时间
}
```
1. `signature`的构成
	1. 先将第一段和第二段密文拼接起来
	2. 对拼接起来的密文字符胡灿和自定义的盐，进行指定(默认HS256)算法加密
	3. 对HS256加密后的密文再做 base64 加密
> 注意：第一、二部分可以通过 `Base64` 解密得到，但第三部分不可以


# JWT的解密过程

当用户再来访问时，会携带token，服务端需要对token进行校验

1. 获取token
2. 对token进行切割成三部分
3. 对第二段字符串进行 `base64` 解密，并检测token是否超时
4. 对第一、二段JSON字符串拼接，再次进行HS256加密，得到密文字符串
5. 将得到的密文字符串与第三部分的签名`signature`进行比对

# 对称加密和非对称加密

## 数据加密

- 加密过程
数据 + 密钥 = 密文
- 解密过程
密文 - 密钥 = 数据

## 对称加密

### 概念
加密算法是公开的。只使用一个密钥加密，必须使用相同的密钥才能解密。
### 优点
算法公开、计算量小、加密速度快、加密效率高
### 缺点
在数据发送前，发送方和接收方必须商定好密钥，然后使双方都能保存好密钥

![[20250118150659.png]]

## 非对称加密
### 概念
加密和解密使用不同的密钥。一把公开的公钥和一把私有的私钥。
公钥加密的信息只有私钥能解密；私钥加密的信息只有公钥能解密。
### 优点
安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。
### 缺点
加密算法非常复杂，安全性医药算法和密钥，而且加密和解密效率很低。

![[20250118150949.png]]

- 工作流程：A生成一对非对称秘钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用私钥解密信息。
# JWT的优缺点

1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。 
2、当JWT未加密方法是，一些私密数据无法通过JWT传输。 
3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。
4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。 
5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。 
6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。