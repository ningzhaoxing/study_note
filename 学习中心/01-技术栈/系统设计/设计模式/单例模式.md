# 实现示例
单例模式确保一个类只有一个实例，通常用于管理共享资源，如配置、缓存、线程池。
1. **懒汉模式**：
在需要使用该实例时再获取。
```go
var (  
    instance *InstanceClass  
    once     sync.Once  
)  
  
type InstanceClass struct {  
}  
  
func GetInstanceClass() *InstanceClass {  
    once.Do(func() {  
       instance = &InstanceClass{}  
    })  
    return instance  
}
```

2. **饿汉模式**：
在服务启动时就初始化好。
```go
var instance1 = &InstanceClass1{}  
  
type InstanceClass1 struct {  
}  
  
func GetInstanceClass1() *InstanceClass1 {  
    return instance1  
}
```

3. **双重检查锁定**：
多线程环境下实现的单例模式。特点是先检查是否已经有实例，

```go
var (  
    instance0 *SingleClass  
    mu        sync.Mutex  
)  
  
type SingleClass struct {  
}  
  
func GetInstance() *SingleClass {  
    if instance == nil {  
       mu.Lock()  
       defer mu.Unlock()  
       if instance0 == nil {  
          instance0 = &SingleClass{}  
       }  
    }  
    return instance0  
}
```

# 分析比较
懒汉模式和饿汉模式的比较：
饿汉模式能够在程序启动时就初始化，不用考虑并发安全问题，但缺点是如果之后没有使用该实例会造成一定资源浪费。

懒汉模式只有在需要使用时初始化，使用 go `once.Do` 实现，并发安全
