存储过程是事先经过编译并存储在数据库中的一段SQL集合。

存储过程的思想就是数据库SQL语言层面的代码封装与重用。
存储过程具有以下三大特点：
1. 封装、复用
	1. 可以把某一业务SQL封装在存储过程中，需要的时候直接调用
2. 可以接收参数和返回参数
	1. 在存储过程中，可以传递参数也可以接收返回值
3. 减少网络交互，效率提高
	1. 如果涉及到多条SQL，每次执行都是一次网络传输。而封装到存储过程中，只需要进行一次网络交互。
# 基本语法
存储函数的语法分为四类：
## 创建
```mysql
# 创建存储过程
create procedure 存储过程名称()
begin
	SQL语句
end;
```

## 调用
```mysql
# 调用存储过程
call 名称
```

## 查看
```mysql
# 查看存储过程

-- 查询指定数据库的存储过程及状态信息
select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'XXX';

-- 查询某个存储过程的定义
show create procedure 存储过程名称;
```

## 删除
```mysql
drop procedure if exists 存储过程名称;
```

# 三种变量
存储过程中存在三种变量：
1. 系统变量
2. 用户自定义变量
3. 局部变量

## 系统变量
是MySQL服务器提供的，不是用户定义的，属于服务器层面。
分为***全局变量***和***会话变量***。

```mysql
# 查看系统变量
-- 查看所有系统变量
show [session | global] variables;

-- 可以通过like模糊匹配查找变量
show [session | global] variables like '...';

-- 直接查看指定变量
select @@[session | golbal].系统变量名;

# 设置系统变量
set [session | global] 系统变量名 = 值;
set @@[session | global].系统变量名 = 值;
```

> 注意：
> - 若没有指定session/global，默认为session
> - mysql服务重启后，全局参数会失效。若不想失效，则需要在 `/etc/my.cnf`中配置。

## 用户自定义变量
是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用"@变量名"即可。其作用域为当前连接。

```mysql
# 赋值
-- 直接赋值
set @var_name = expr [, @var_name = expr] ...;
set @var_name := expr ...;
select @var_name := expr ...;

-- 从表中抽取数据进行赋值
select 字段名 into @var_name from 表名;

# 使用
select @var_name;
```
> 注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。

## 局部变量
是根据需要定义的在局部生效的变量，访问之前，需要`declare`声明。
可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的`begin...end`块。
```mysql
# 声明
declare 变量名 变量类型 [default ...]

# 赋值
set 变量名 = 值;
set 变量名 := 值;
select 字段名 into 变量名 from 表名 ...;
```

# 七种结构
MySQL同样设置了相关判断和循环结构：
1. if 
2. case 
3. while
4. repreat
5. loop
6. cursor
7. handler

参数设置：

| 类型   | 含义                 | 备注  |
| ---- | ------------------ | --- |
| IN   | 传入的参数              | 默认  |
| OUT  | 返回值                |     |
| INOT | 既可以作为传入的参数也可以作为返回值 |     |
用法如下：
```mysql
create procedure 存储过程名称 ([in/out/inout 参数名 参数类型])
begin
-- sql 语句
end;
```

两个案例：
1. 分数等级转换
```mysql
create procedure p4(in score int, out result varchar(10))
begin
	if score >= 85 then
		set result := '优秀';
	elseif score >= 60 then
		set result := '及格';
	else 
		set result := '不及格';
	end if;
end;

call p4(68, @result);
select @result;
```

2. 200分制转百分制
```mysql
create procedure p5(inout score double)
begin 
	set score := score*0.5
end;

set @score = 78;
call p5(@score);
select @score;
```

## IF结构
```mysql
if 条件1 then
...
elseif 条件2 then -- 可选
...
else - 可选
...
end if;
```

## case结构
```mysql
# case结构1：
-- 当case_value的值为when_value1时，执行statement_list1,
-- 当值为when_value2时，执行statement_list2,
-- 否则就执行statement_list

case case_value
	when when_value1 then statement_list1
	[when when_value2 then statement_list2]...
	[else statement_list]
end case;	

# case结构2：
-- 当条件search_condition1成立时，执行statement_list1，
-- 当条件search_condition2成立时，执行statement_list2
-- 否则就执行 statement_list

case 
	when searc_condition1 then statement_list1
	[when search_condition2 then statement_list2] ...
	[else statment_list]
end case;
```

## while结构
```mysql
# while循环结构

while 条件 do
	sql逻辑...
end while;
```

## repeat结构
```mysql
# repeat循环结构

-- 相当于do-while循环
repeat 
	sql逻辑...
	until 条件
end repeat;
```

## loop结构
`loop`可以实现简单的循环，如果不在sql逻辑上增加退出循环条件，可以用其来实现简单的死循环。
`loop`结构需要配合两个语句使用：
- `leave`：退出循环
- `iterate`：必须用在循环中，跳过当前循环剩余语句，直接进行下次循环
```mysql
[begin_label:] loop
	sql逻辑
end loop [end_label];
```

案例：计算从1到n之间的偶数累加的值，n为传入的参数值。
```mysql
-- A. 定义局部变量, 记录累加之后的值; 
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx 
-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------> iterate xx

create procedure p10(in n int)
begin
	declare total int default 0;

	-- 进入loop循环
	sum:loop
	if n<=0 then
	leave sum;
	end if;
	
	-- 奇数跳过
	if n%2 = 1 then
	set n:=n-1;
	iterate sum;
	end if;

	set total:=total+n;
	set n:=n-1;

	end loop sum;

	-- 输出结果
	select total;
end;

-- 执行存储过程
call p10(100);
```

## cursor(游标)结构
