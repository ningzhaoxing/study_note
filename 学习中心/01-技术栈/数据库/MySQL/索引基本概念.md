# 索引分类

## 按数据结构
- B+树索引
- Hash索引
- Full-text索引
## 按物理存储方式
- 聚簇索引
- 二级索引
## 按字段特性
- 主键索引
- 唯一索引
- 前缀索引
## 按字段个数
- 单列索引
- 联合索引

# B+树索引
## 数据结构
- B+树是**一种多叉树**，叶子节点存储数据和索引，非叶子节点只存放索引，而且每个节点里的数据是按**主键顺序存放**的。
- 每一层父节点的索引值都会出现在下层节点的索引值中，因此叶子节点包括了所有的索引值信息。
- 叶子节点形成一个**双向链表**。叶子节点都有两个指针，一个指向下一个节点，另一个指向上一个节点。

### 主键索引B+树
![[Pasted image 20250402145522.png]]

### 二级索引B+树
![[Pasted image 20250402145744.png]]

#### 主键索引B+树与二级索引B+树区别:
> 主键索引B+树叶子节点存储的是**所有的具体数据**，而二级索引的叶子节点存储的是主键值。

#### 二级索引查询过程
1. 先找到对应的叶子节点，获取到对应的主键值
2. **回表**：通过主键索引中的B+树查询对应的叶子节点，获取到整行数据
等于说，要查两个B+树。
> 不过，如果需要查找的数据在二级索引的B+树叶子节点中能查询到，就不需要回表。
> 例如：`select id from product where product_no = '0002'`
> 这种在二级索引的B+树就能查询到结果的过程叫做**覆盖索引**，也就是只需查一个B+树就能找到数据。

# 为什么InnoDb使用B+树索引

## B+ tree vs B tree
- **单节点数据量更小，相同磁盘IO次数下，能查询更多的节点**。B+树只在叶子节点存储数据，B树的非叶子节点也要存储数据。

## B+ tree vs 二叉树
- **二叉树树的高度更高，需要经过更多的磁盘IO。**
	B+ tree查询复杂度为`O(logdN)`，d为节点允许的最大子节点个数。d的值是大于100的，即使到千万级别数据，B+ tree也只需要做3~4此磁盘IO。
	而二叉树的子节点只能是两个，导致树的高度会更高。
## B+ tree vs hash
- **hash不支持范围查询**

# 索引下推

建立联合索引，`age`和`reward`。
执行sql `select * from t_user where age > 20 and reward = 1000;`

由于`age > 20`会导致联合索引在匹配到这里就会停止，`age`用到了联合索引，而`reward`没使用到。

此时，会先从B+树中找到第一条符合`age>20`的索引记录，并比对该记录中的`reward`是否等于`1000`，如果等于这执行回表操作，把数据返回给Server层；如果不等于则跳过该二级索引。