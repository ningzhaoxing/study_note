# 1. 开启慢查询日志

```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.5;
SET GLOBAL log_queries_not_using_indexes = 1;
```

# 2. 复杂查询过程分析

```sql
SELECT * FROM employees JOIN salaries
	ON employees.emp_no = salaries.emp_no AND salaries.from_date = 'xxxx-xx-xx'
WHERE employees.emp_no > 50 AND salarires.salary > 10000
ORDER BY salaries.salary;

-- employees:PRIMARY KEY(emp_no)
-- salaries:PRIMARY KEY(emp_no, from_date)

```

`JOIN` + `WHERE` + `ORDER BY`

执行过程：
- 根据 `emp_no` 主键索引直接定位到对应 `emp_no > 50` 的记录
	- 根据 `emp_no, from_date` 去查 salaries 表
	- 根据 `PRIMARY KEY(emp_no, from_date)` 直接定位到 salaries.from_date = 'xxxx-xx-xx' 的位置
	- 如果定位到的结果 salarires.salary > 10000，则把 `JoinedRow(employees[i],salaries[j]` 加入到 JOIN 结果集
- 拿到 JOIN 结果集后，根据 `salaries.salary` 排序

# 2. Explain 关键字

## 2.1 Explain format=tree
explain 简洁信息

![[Pasted image 20251017171324.png]]

## 2.2 Explain format=json
explain 详细信息
 

## 2.3 优化器重写 sql

```sql
EXPLAIN ...
SHOW warnings;
```

## 2.4 主要关注哪些字段？

1. **type** （访问类型）
	1. system：
	2. const：通过主键或唯一索引精确匹配
	3. eq_ref：多表连接时，被连接表通过主键/唯一索引匹配，被连接表只返回一条结果
	4. ref：非唯一索引匹配，被连接表返回多条结果
	5. range：索引范围查询（`where id between 1 and 10` 或 `id in (1,2)`）
	6. index：扫描全索引，需要遍历整棵索引树
	7. all：全表扫描
2. **key**（使用的索引）
	1. 实际使用的索引名称（`PRIMARY`主键索引 和 `idx_name`普通索引）
	2. 若为 `NULL`，表示未使用任何索引
3. **rows**（预估扫描行数）
	1. mysql 预估扫描行数，越小越好
4. **extra**（额外信息）
	1. `using index`：使用了覆盖索引
	2. `using where`: where 过滤
	3. `using temporyary`：需要创建临时表存储结果（）
	4. `using filesort`：

# 3. 制造复杂慢查询

## 3.1 Join 类

```sql
select * from employees
	join salaries on employees.emp_no = salaries.emp_no
limit 10;
```

只需要给 salaries.emp_no 加上索引即可，直接定位到对应的记录。

## 3.2 Where 类

### 3.2.1 一个 where

```sql
select * from employees
	join salaries on employees.emp_no = salaries.emp_no
where salaries.salary > 1000
limit 10;
```
给 salary 字段加上索引即可，可以直接定位到 `salary>1000` 的记录，不过需要回表。

### 3.2.2 多个 where

```sql
select * from employees
	join salaries on employees.emp_no = salaries.emp_no
where salaries.salary > 1000 and salaries.from_data > 'xxxx-xx-xx'
limit 10;
```

因此二级索引需要进行回表操作，所以太多字段都加索引回表开销可能会比较大。所以分别给每个字段都建一个索引，实际执行时，用筛选效果最好的那个。

## left join



# 1. 定位性能瓶颈

## 1.1 启动慢查询雷达



