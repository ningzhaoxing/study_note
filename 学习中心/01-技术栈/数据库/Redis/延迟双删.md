# 常见缓存策略

## 先删缓存后更库

在删除缓存后，有线程从库中读取到旧数据，然后写回到缓存，造成**长期数据不一致**

## 先更库再删缓存

1. 在更新库前且缓存刚好失效，有线程读取数据库的旧数据，此时该线程在更库和删除缓存前，再写回到缓存，就会出现短暂的数据不一致的情况。
2. 在**数据库主从**的情况下，主数据库数据同步到从数据库需要时间，在这个过程中线程所读到的脏数据写回至缓存，会造成**长期数据不一致**。


这种策略要比 先删缓存再更库的一致性好一些。

## 普通双删

先删除缓存，再更新数据库，最后再删除缓存。
当线程从数据库中读取到旧数据，并在第二次删除缓存后写回到缓存，就会出现数据不一致情况。


总结，我们要保证缓存中是数据库中的最新数据，就要保证在 **更新库 -> 删除缓存** 过程中更新数据库之前所读到的旧数据在删除缓存之后缓存被删除。
# 延迟双删策略

所以，延迟双删策略就是
1. 先**删除缓存**，让后续的请求都走数据库（这个过程在更新完数据库前都会读到旧数据，有缓存旧数据的风险）。
2. 然后**更新数据库**
3. 延迟等待数据库更新完毕(可以包括主从同步)后，**再次删除缓存**
	1. 此时，将更新数据库前缓存的旧数据全部删除。之后读到的就是更新数据库后
	2.  缓存失效时读取的脏数据因为再延迟删除，大部分也会被删掉

但依然存在的缓存短暂不一致可能：
1. 缓存失效时，读取到旧数据，在更新数据库后和第二次删除缓存前缓存了旧数据
2. 在第一次删除缓存后和更新数据库前，会从数据库中读到脏数据

# 总结

在单数据库场景，“先更新数据库，再删除缓存”的策略基本可以解决长期数据不一致的问题。但在主从架构中，延迟双闪策略能够极大的避免出现长期缓存不一致问题。

从长期和复用角度看，延迟双删策略更适用。