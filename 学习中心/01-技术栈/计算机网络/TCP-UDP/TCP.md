# 拥塞控制

避免发送方过度发包导致网络拥塞。
## 过程
四个量：发送窗口(=min(接收窗口,拥塞窗口))、接收窗口、拥塞窗口、慢开始门限。

1. 初始：
	进行**慢开始**算法：
	拥塞窗口为1，拥塞窗口成倍增加。

2. 当拥塞窗口>慢开始门限：
	进行**拥塞避免**算法：
	拥塞窗口按线性增加

3. 当发送方收到三个重复的ACK
	进行**快重传**、**快恢复**算法：
	发送方将慢开始门限和拥塞窗口调整问当前窗口的一半，开始执行拥塞避免算法。
	***作用***：表明轻度拥塞，TCP通效率和稳定性。过**快速恢复**（窗口减半 + 拥塞避免）平衡

5. 发生超时重传(发送方报文段丢失)：***TCP重置***
	将**慢开始门限**更新为发生**拥塞时拥塞窗口**的一半；
	将**拥塞窗口**减少为1，并重新执行**慢开始算法**
	*作用*：超时说明当前网络拥塞比较严重，可以确保发送方在重新开始发送数据时，不会因发送速率过快而再次导致拥塞。这种做法有助于网络逐步恢复，提高网络的性能和可靠性
##  其他
1. 拥塞控制解决了什么问题？
	**问题**：在没有拥塞控制的情况下，当网络中数据流量过大时，网络中的路由器和交换机等设备的缓冲区会被迅速填满。
	一旦填满，后续到达的数据包就会丢弃，导致大量数据丢失，导致引发网络中的重传机制，进一步加剧网络拥塞，最终导致网络瘫痪。
	**解决方式**：tcp通过拥塞控制算法来动态调整发送方的发送速率，根据网络拥塞情况来控制发送到网络中的数据量。


# 三次握手（四元组：源ip、目的ip、源端口号、目的端口号）

![[TCP三次握手.png]]

## 为什么是三次，而不是两次？

为了防止旧的重复无效连接

场景：
客户端向服务端发送SYN报文后，客户端宕机了，然后因为网络拥塞导致服务端还没收到，直到客户端重启，又向服务端建立连接。

因为两次握手服务端没有中间状态来让客户端确认服务端的ACK确认建立连接是否是有效的，导致建立了无效的历史连接。而三次握手客户端在收到无效的ACK后，告诉服务端中止连接。

## 若第二次握手后，客户端宕机
### 此时会浪费的资源

1. 端口号被占用
2. 内存资源
3. CPU资源
4. 网络带宽

### 处理措施
1. 超时重传机制
	当重传次数超过最大重传次数时，服务端会主动丢弃并关闭连接
2. 半连接队列超时
	操作系统会维护一个半连接队列，将半连接放入其中，并设置一个超时时间，如果一个半连接在超时时间内未完成三次握手，也会被丢弃。
# 四次挥手

![[秋招/计网面经/传输层/TCP.UDP/assets/TCP/file-20250517171239935.png]]


## 第一次挥手丢失

超过最大重传次数+1(每次重传会等待上一次超时时间的2倍)后，如果没收到服务端的ACK，则客户端断开连接。

## 第二次挥手丢失

第一次挥手后，客户端进入 `fin wait` 状态，超过最大重传次数+1后，没有接收到服务端的ACK，则会断开连接。

## 第三次挥手丢失

服务端 `closed_wait`状态结束后(即应用进程调用`close()`关闭连接)，向客户端发送`FIN`丢失。如果超过最大重传次数+1后，还是未能收到客户端的第四次挥手，则会主动断开连接。
同时客户端的`fin_wait_2`状态有时长限制，如果在时间内未收到第三次挥手，则客户端也会断开连接。

## 第四次挥手丢失

客户端接收到服务端的第三次挥手后，会进入`time_wait`状态。在 linux系统中，`time_wait`状态会持续2个`MSL`后才会进入关闭状态。

所以，如果客户端的第四次挥手一直丢失，服务端在重发超过最大重传次数+1后，则会关闭。同时客户端超过2个`MSL`后，也会关闭。

## 为什么要有`time_wait`状态

两个原因：
## 1. 防止历史连接的数据被后面相同的四元组连接错误接收
避免相同的四元组连接收到旧的报文。

当没有`time_wait`状态或时间过短时，被延迟的数据包可能会在相同端口号的TCP连接重启后到达，此时如果该数据报文的序列号刚好在客户端的接收窗口内，此时客户端就会错误地接收上个连接残留下来的数据。

## 2.保证被关闭连接的一方，能被正确关闭

为了保证客户端的第四次挥手可以被服务端正确接收到，如果没有`time_wait`状态，客户端发送第四次挥手后，直接进入`close`状态。
而此时服务端重传的`FIN`报文，到达时客户端已经关闭。此时，客户端会返回`RST`报文，进行异常中止。

为了避免这种情况，客户端需要等待足够的时间，确保服务端接收到ACK，若没有接收到，则会触发重传机制，刚好是两个`MSL`的时间。

## 为什么`time_wait`的等待时候为2`MSL`

`MSL`:报文最大生存时间。即，任何报文在网络中存在的最长时间。
`TTL`:是报文经过的路由跳数。

2个`MSL`刚好就是报文在网络中一来回的最大时间间隔。
2个`MSL`的时长就规定了 至少允许报文丢失一次。如果ACK在第一个`MSL`内丢失，这样被发送方重发的`FIN`报文会在，第2个`MSL`内到达，从而重新第四次握手。

