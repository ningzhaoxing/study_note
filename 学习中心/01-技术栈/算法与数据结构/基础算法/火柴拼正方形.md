# 题面
## 链接
[473. 火柴拼正方形 - 力扣（LeetCode）](https://leetcode.cn/problems/matchsticks-to-square/?envType=problem-list-v2&envId=LBZR6IMZ)

![[20250116204519.png]]

# 解题思路

因为正方形的四条边是相等的，所以`totalLen`一定是4的倍数，即 `totalLen % 4 == 0`。同时，不可能存在大于正方形边长的火柴。
综上，

```go
if totalLen%4 != 0 || maxMatchstick > totalLen/4 {
	return false
}
```
其次，每个火柴有四个选择，来组成正方形的某一个边。可以通过dfs来搜索所有的情况，如果所有的火柴都可以被放置，则说明可以拼成正方形。
当一条边超过`totalLen/4`时，这条边就无法放置该火柴，若小于等于`totalLen/4`，则可以继续放置火柴。

剪枝：
1. 当当前火柴放在当前边时，超过了`totalLen/4`则在此节点下的子树都是不符合题意的，进行回溯剪枝，搜索其他边。
2. 当四条边都无法放置该火柴，则说明此节点的上一个节点以下的子树都是不符合题意的，对上一个节点进行回溯，搜索其他边。
```go
func dfs(idx int) bool {
	// 如果此条分支，最后一个火柴也被放置，则返回true
	if idx == len(matchsticks) {
		return true
	}
	// 每个火柴遍历四种边的选择
	for i := range edges {
		edges[i] += matchsticks[idx]  // 将当前火柴加入到第i条边
		// 如果当前边小于等于totalLen/4， 并且当前节点下有子树分支是可以全部放置的，则说明当前节点及其下某分支是可以全部放置的
		if edges[i] <= totalLen/4 && dfs(idx+1) {
			return true
		}
		edge[i] -= matchsticks[idx]  // 如果火柴选择该边大于totalLen/4或此节点下没有子树分支可以满足条件，则进行回溯，搜索尝试其他边
	}
	return false  // 如果所有边都无法放置该火柴，则说明到该节点不可能有满足条件的子树分支
}  
```

# AC代码

```go
func makesquare(matchsticks []int) bool {
    totalLen := 0
    for i := 0; i < len(matchsticks); i++ {
        totalLen += matchsticks[i]
    }

    if totalLen%4 != 0 {
        return false
    }

    sort.Sort(sort.Reverse(sort.IntSlice(matchsticks)))
    if matchsticks[0] > totalLen/4 {
        return false
    }

    edges := [4]int{}
    var dfs func(int) bool
    dfs = func(idx int) bool {
        if idx == len(matchsticks) {
            return true
        }
        for i := range edges {
            edges[i] += matchsticks[idx]
            if edges[i] <= totalLen/4 && dfs(idx+1) {
                return true
            }
            edges[i] -= matchsticks[idx]
        }
        return false
    }
    return dfs(0)
}
```

# 总结

1. dfs()是一个深度优先搜索函数，也是一个寻找满足条件路径的答案。
2. dfs(idx) == true指明，idx以下的子树有分支满足条件