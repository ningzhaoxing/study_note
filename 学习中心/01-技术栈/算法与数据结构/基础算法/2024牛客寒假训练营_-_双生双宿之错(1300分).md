# 题面
[双生双宿之错]([E-双生双宿之错_2025牛客寒假算法基础集训营1](https://ac.nowcoder.com/acm/contest/95323/E))
# 解题思路
双生数组的要求：
1. 序列中只有两种元素
2. 两种元素的个数相同

由题目已知，序列的大小一定为偶数，则无需判断。

假设，两种元素分别为`x`,`y`。那么，则需要把序列中所有元素变为`x`,`y`。
那`x`和`y`怎么取值呢？

***中位数定理***
> 对于一组实数 x1,x2,…,xnx1​,x2​,…,xn​，中位数是使得所有数据点到该点的绝对偏差之和最小的值。

那么序列中的所有数变成其中位数的代价就最小。

因此，我们可以将该序列进行排序，求出前半部分的中位数`x`和后半部分的中位数`y`。
如果，`x!=y`，那么，计算整个序列需要转化为`x`或`y`的代价即可。
如果，`x==y`，则需要枚举`x-1`,`y`或`x`,`y+1`的情况。

# AC代码
```go
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+7;
int a[N];

int getSum(int x, int y, int n) {
    int ans=0;
    for (int i = 1; i <= n; ++i) {
        if (i <= n/2) {
            ans += abs(a[i]-x);
        } else {
            ans += abs(a[i]-y);
        }
    }
    return ans;
}

int getZhong(int i, int j) {
    if ((j-i+1)%2!=0) return a[(i+j)/2];
    int x1 = a[(i+j)/2];
    int x2 = a[(i+j)/2+1];
    return round((x1+x2)/2);
}

void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    sort(a+1,a+n+1);

    // 左边中位数
    int x = getZhong(1, n/2);
    int y = getZhong(n/2+1,n);
    int ans;
    if (x==y) {
        int ans1 = getSum(x-1, y, n);
        int ans2 = getSum(x, y+1, n);
        ans = min(ans1, ans2);
    } else {
        ans = getSum(x,y,n);
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t = 1;
    cin >> t;
    while (t--) solve();
}
```

# 总结
中位数定理
> 对于一组实数 x1,x2,…,xnx1​,x2​,…,xn​，中位数是使得所有数据点到该点的绝对偏差之和最小的值。

如何找区间内的中位数
```go
int getZhong(int i, int j) {
    if ((j-i+1)%2!=0) return a[(i+j)/2];
    int x1 = a[(i+j)/2];
    int x2 = a[(i+j)/2+1];
    return round((x1+x2)/2);
}
```