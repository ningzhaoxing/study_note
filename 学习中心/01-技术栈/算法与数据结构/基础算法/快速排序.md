# 工作原理

通过**分治**的方式将一个数组排序。
快速排序分为两个过程：
1. 将数列划分为两部分，并保证相对大小关系
2. 递归到两个子序列中继续进行步骤一

# 代码实现

```go
func partition(arr []int, low, high int) int {  
    pivot := arr[low]  
    for low < high {  
       for low < high && arr[high] >= pivot {  
          high--  
       }  
       arr[low] = arr[high]  
       for low < high && arr[low] <= pivot {  
          low++  
       }  
       arr[high] = arr[low]  
    }  
    arr[low] = pivot  
    return low  
}  
  
func QuickSort(arr []int, low, high int) {  
    if low < high {  
       pivot := partition(arr, low, high)  
       QuickSort(arr, low, pivot-1)  
       QuickSort(arr, pivot+1, high)  
    }  
}
```

# 时间复杂度分析

- 当每次选择的分界值都是序列的中位数时，`l`和`r`指针刚好一起走完子序列，因此时间复杂度为`O(nlogn)`
-  当每次选择的分界值都是序列的最值时，`l`或`r`会单独走完子序，因此时间复杂度为`O(n^2)`

当测试用例为，如`2222222222....`时，每次划分的子序列都会使得一个指针走完子序列，时间复杂度降级为`O(n^2)`，因此需要优化。

# 算法优化
目前，常见的优化思路如下三种：
1. 三数取中
	选第一个、最后一个和中间元素的中位数作为基准。
2. 当序列较短时，使用**插入排序**
3. 每趟排序，将**与分别元素相等的元素聚集在分界元素周围**，这样可以避免序列中大部分元素都相等带来的退化

## 三路快速排序




