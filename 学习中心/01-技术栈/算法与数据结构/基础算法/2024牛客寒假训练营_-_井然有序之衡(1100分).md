# 题面
[井然有序之衡][G-井然有序之衡_2025牛客寒假算法基础集训营1](https://ac.nowcoder.com/acm/contest/95323/G)

# 解题思路

> 在一个排列中，选择一个元素进行+1，同时则需要另一个元素进行-1。
> 本质上，是在这个序列中进行值得转移过程。所以在这个排列中的总和是守恒不变的。

判断无法生成排列的情况：
如果给出的序列的总和***不等于***长度为n排列的总和(即n*(n+1)/2)，那么必然无法生成排列。

若能生成排列：
将给出的序列进行排序。因为该序列排序后，与排列所对应位置的元素就是距离最近的，所以将该序列每一个位置上的数字都变成排列对应的数字就是最优的。
那么只需要计算出序列中大于或小于对应排列的数字的差值总和，就是需要付出的代价。

# AC代码
```go
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+7;
int a[N];
void solve() {
    int n;
    cin >> n;
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        sum += a[i];
    }

    if (sum != n*(1+n)/2) {
        cout << -1;
        return;
    }

    sort(a+1,a+n+1);
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] > i) {
            ans += a[i]-i;
        }
    }
    cout << ans;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t = 1;
//    cin >> t;
    while (t--) solve();
}
```

