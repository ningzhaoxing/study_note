[题目链接]([15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked))

# 解题思路

可将三数之和的问题转化为两数之和。
将数组进行排序后，
枚举`target`，同时使用双指针找到其它两个数。

如何进行去重？

> 将三个指针分别定义为`i`、`l`、`r`， 
> 当枚举到`nums[i]`时，会将当前的枚举结果加入`ans`，若枚举到`nums[i+1] == nums[i]`时，再进行双指针查找，很大可能会出现重复的结果。
> 同样，当`nums[l] == nums[l-1]`，`nums[r] == nums[r+1]`时，也会出现重复的结果。

# AC代码

```go
func threeSum(nums []int) [][]int {  
    sort.Ints(nums)  
  
    ans := make([][]int, 0)  
    for i := 0; i < len(nums); i++ {  
       if i != 0 && nums[i] == nums[i-1] {  
          continue  
       }  
       target := -nums[i]  
       l, r := i+1, len(nums)-1  
       for l < r {  
          sum := nums[l] + nums[r]  
          if sum == target {  
             ans = append(ans, []int{-target, nums[l], nums[r]})  
             l++  
             r--  
             // 重复去重
             for l < r && nums[l] == nums[l-1] {  
                l++  
             }  
             for l < r && nums[r] == nums[r+1] {  
                r--  
             }  
          } else if sum > target {  
             r--  
          } else {  
             l++  
          }  
       }    
    }    
    return ans  
}
```

# 提问

## 为什么`sum > target`或`sum < target`时无需去重？

因为此时不满足加入`ans`的条件，即使下一个遍历元素与当前元素相同，也不会加入到`ans`。

重复的情况只存在于满足加入`ans`的条件的情况，又进行了多次添加。

# 思悟

双指针问题的核心是在于“代价”的平衡，通过移动两个指针去平衡“代价”，保证寻找到自己要找的元素。
因此，双指针的使用需要满足对象的代价是可以控制其平衡和不平衡状态。