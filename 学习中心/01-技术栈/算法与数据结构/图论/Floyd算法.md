- 多源最短路算法
- 用于求任意两个结点之间的最短路
- 算法时间复杂度O(n^3)
- 适用于任何图，不管有向无向，边权正负，但最短路必须存在。(不能有个负环)
**动态规划**思想。

# 递推式
定义数组 `f[k][x][y]`，表示只允许经过结点1到k，结点x到结点y的最短路长度。
因此，`f[n][x][y]`就是结点x到结点y的最短路长度。

 **递推式**：
 > - `f[0][x][y]`: 为x与y的边权，或者0，或者无穷大。
 > - `f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])`
 
`f[k-1][x][y]`，为不经过 k 点的最短路径，而 `f[k-1][x][k]+f[k-1][k][y]`，为经过了 k 点的最短路）

因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成 `f[x][y] = min(f[x][y], f[x][k]+f[k][y])`。

因此，递推式为：
 > - `f[x][y]`: 为x与y的边权，或者0，或者无穷大。
 > - `f[x][y] = min(f[x][y], f[x][k]+f[k][y])`

# 应用
## 正权无向图求最小权值和的环
考虑环上编号最大的结点`u0`
`f[u-1][x][y]`和(u,x)(u,y)共同构成了环.
在*Floyd*的过程中枚举u,计算这个和的最小值即可

## 已知一个有向图中任意两点之间是否有连边,要求判断任意两点是否连通.
该问题即求 **图的传递闭包**
按照 Floyd 的过程,逐个加入点判断一下.
只是此时的边的边权变为1/0,而取min变成了 **或** 运算.
```go
for k:=1;k<=n;k++ {
	for i:=1;i<=n;i++ {
		if (f[i][k]) f[i]=f[i] | f[k];
	}
}
```

# 代码实现
```c++
for (k = 1; k <= n; k++) { 
	for (x = 1; x <= n; x++) { 
		for (y = 1; y <= n; y++) { 
			f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
		} 
	} 
}
```
