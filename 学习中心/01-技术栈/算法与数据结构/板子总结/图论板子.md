# 求树的最大深度
## dfs求
```c++
int dfs(int x) {
	vis[x]=1;
	int maxL=0;
	for (int i=1;i<=n;i++) maxL = max(maxL, dfs(graph[x]+1))
	return maxL;
}
```

# 求最短路
## 单源最短路
### bfs求
无权图
```go
func bfs(start, n int, g [][]int) []int {  
    dis := make([]int, n)  
    for i := 0; i < len(dis); i++ {  
       dis[i] = -1  
    }  
    q := make([]int, 0)  
    q = append(q, start)  
    dis[start] = 0  
  
    for len(q) > 0 {  
       x := q[0]  
       q = q[1:]  
       for _, y := range g[x] {  
          if dis[y] < 0 {  
             dis[y] = dis[x] + 1  
             q = append(q, y)  
          }  
       }  
    }  
    return dis  
}
```

## Dijkstra
正权图
```c++
struct DIJ {
    using i64 = long long;
    using PII = pair<i64, i64>;
    vector<i64> dis;
    vector<vector<PII>> G;
 
    DIJ() {}
    DIJ(int n) {
        dis.assign(n + 1, 1e18);
        G.resize(n + 1);
    }
 
    void add(int u, int v, int w) {
        G[u].emplace_back(v, w);
    }
 
    void dijkstra(int s) {
        priority_queue<PII> que;
        dis[s] = 0;
        que.push({0, s});
        while (!que.empty()) {
            auto p = que.top();
            que.pop();
            int u = p.second;
            if (dis[u] < p.first) continue;
            for (auto [v, w] : G[u]) {
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    que.push({ -dis[v], v});
                }
            }
        }
    }
};
```
![[file-20250509132955057.png]]

### SPFA
任何图
![[file-20250509133648318.png]]


## 全源最短路
### Floyed算法
任何图
![[file-20250509133530891.png]]

# 最小生成树
##  Kruskal算法
```cpp
/*
每个点最初是一个连通块，每次选取边权最小的边，当边连接的是两个不同的连通块，把他们合并成一个连通块，直至生成树中有n个点
*/

const int MAXN=1e5+10;
int pre[MAXN];

struct edge
{
    int u,v,cost;
    edge(int u,int v,int cost): u(u), v(v), cost(cost){};
};

bool cmp(edge e1, edge e2) {
    return e1.cost < e2.cost;
}

vector<edge> edges;

// 初始化并查集
void init(int n)
{
    for(int i = 1; i <= n; i ++){
        pre[i]=i;
    }
}

//寻找父节点
int find(int x) {
    if (pre[x]==x) return x;
    return pre[x]=find(pre[x]);
}

//合并
void unionsets(int a,int b) {
    a=find(a);
    b=find(b);
    if (a!=b) pre[a]=b;
}
void solve()
{
    int a,b,n;
    cin >> a >> b >> n >> m;

    memset(pre,-1,sizeof(pre));
    edges.clear();

    //初始化已经连通的结点
    for(int i = 1; i <= n; i ++){
        int u,v;
        cin >> u >> v;
        edges.push_back(edge(u, v, 0));
    }

    // 利用克鲁斯卡尔算法生成最小树
    // 算法步骤：1.对边的权值(代价)进行排序 2.通过并查集判环

    sort(edges.begin(),edges.end(),cmp);

    //初始化并查集
    init(a+b+1);

    int maxn=-1;
    for(int i = 0; i < edges.size(); i ++){
        edge e=edges[i];
        //如果不在同一个集合，即不会形成回路
        if (find(e.u) != find(e.v)) {
            unionsets(e.u, e.v);
            maxn=max(maxn, e.cost);
        }
    }

    //生成树结束后，判断图的连通性。
    //若连通则输出maxn，否则输出-1
    int rt = find(1);
    for(int i = 2; i <= a+b; i ++){
        if (find(i) != rt) {
            cout << -1 << endl;
            return;
        }
    }
    cout << maxn << endl;
}
```

# 拓扑排序
```cpp
// 每次找入度为0的节点，然后去掉其所有边，继续找
void topology_sort() {
	for(int i=1; i<=m; ++i) {//m条边 
		cin>>x>>y;
		edge[x].push_back(y);
		in[y]++;//in[i]表示入度 
	}
	for(int i=1; i<=n; ++i) {//n个点 
		if(in[i]==0) {
			q.push(i);//入度为0就把它加入队列 
		}
	}

	while(!q.empty()) {
		int t=q.front();
		ans.push_back(t);
		q.pop();
		for(int i=0; i<edge[t].size(); ++i) {
			in[edge[t][i]]--;
			if(in[edge[t][i]]==0) q.push(edge[t][i]);
		}
	}
}
```
拓扑判环：
如果取出来点的数量和点的个数相同，那么它是无环的。如果取出来点的数量小于点的个数则是有环的。

# ST表
![[file-20250509151326689.png]]
# 最近公共祖先
性质：
![[file-20250509152838665.png]]
模板：
```cpp
#include <cstring>  
#include <iostream>  
#include <vector>  
  
constexpr int MXN = 40005;  
using namespace std;  
vector<int> v[MXN];  
vector<int> w[MXN];  
  
int fa[MXN][31], cost[MXN][31], dep[MXN];  
int n, m;  
int a, b, c;  
  
// dfs，用来为 lca 算法做准备。接受两个参数：dfs 起始节点和它的父亲节点。  
void dfs(int root, int fno) {  
    // 初始化：第 2^0 = 1 个祖先就是它的父亲节点，dep 也比父亲节点多 1。  
    fa[root][0] = fno;  
    dep[root] = dep[fa[root][0]] + 1;  
    // 初始化：其他的祖先节点：第 2^i 的祖先节点是第 2^(i-1) 的祖先节点的第  
    // 2^(i-1) 的祖先节点。  
    for (int i = 1; i < 31; ++i) {  
        fa[root][i] = fa[fa[root][i - 1]][i - 1];  
        cost[root][i] = cost[fa[root][i - 1]][i - 1] + cost[root][i - 1];  
    }    // 遍历子节点来进行 dfs。  
    int sz = v[root].size();  
    for (int i = 0; i < sz; ++i) {  
        if (v[root][i] == fno) continue;  
        cost[v[root][i]][0] = w[root][i];  
        dfs(v[root][i], root);  
    }}  
  
// lca。用倍增算法算取 x 和 y 的 lca 节点。  
int lca(int x, int y) {  
    // 令 y 比 x 深。  
    if (dep[x] > dep[y]) swap(x, y);  
    // 令 y 和 x 在一个深度。  
    int tmp = dep[y] - dep[x], ans = 0;  
    for (int j = 0; tmp; ++j, tmp >>= 1)  
        if (tmp & 1) ans += cost[y][j], y = fa[y][j];  
    // 如果这个时候 y = x，那么 x，y 就都是它们自己的祖先。  
    if (y == x) return ans;  
    // 不然的话，找到第一个不是它们祖先的两个点。  
    for (int j = 30; j >= 0 && y != x; --j) {  
        if (fa[x][j] != fa[y][j]) {  
            ans += cost[x][j] + cost[y][j];  
            x = fa[x][j];  
            y = fa[y][j];  
        }    }    // 返回结果。  
    ans += cost[x][0] + cost[y][0];  
    return ans;  
}  
  
void Solve() {  
    cin.tie(nullptr)->sync_with_stdio(false);  
    // 初始化表示祖先的数组 fa，代价 cost 和深度 dep。  
    memset(fa, 0, sizeof(fa));  
    memset(cost, 0, sizeof(cost));  
    memset(dep, 0, sizeof(dep));  
    // 读入树：节点数一共有 n 个，查询 m 次，每一次查找两个节点的 lca 点。  
    cin >> n >> m;  
    // 初始化树边和边权  
    for (int i = 1; i <= n; ++i) {  
        v[i].clear();  
        w[i].clear();  
    }    for (int i = 1; i < n; ++i) {  
        cin >> a >> b >> c;  
        v[a].push_back(b);  
        v[b].push_back(a);  
        w[a].push_back(c);  
        w[b].push_back(c);  
    }    // 为了计算 lca 而使用 dfs。  
    dfs(1, 0);  
    for (int i = 0; i < m; ++i) {  
        cin >> a >> b;  
        cout << lca(a, b) << '\n';  
    }}  
  
int main() {  
    cin.tie(nullptr)->sync_with_stdio(false);  
    int T;  
    cin >> T;  
    while (T--) Solve();  
    return 0;  
}
```

# 树状数组
用于**单点查询**和**区间查询**
一维
```cpp
struct BIT{ //树状数组 
	int c[N], lowbit(int x){return x & -x;} 
	void update(int x, int k){while(x < N) c[x] += k, x += lowbit(x);} 
	int query(int x){int s = 0; while(x) s += c[x], x -= lowbit(x); return s;} // 查询区间[1,x]的和
} t;
```
