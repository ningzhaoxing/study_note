# 结构
二叉堆是一棵完全二叉树，每个节点存有一个元素(或者说权值)。

# 过程
## 插入操作
插入操作要将一个元素插入二叉堆中，并保证插入后也是一棵完全二叉树。
最简单的方法就是，在最后一层的最右边的叶子之后插入，如果最后一层已满，就新增一层。
若插入后，不满足堆的性质，则进行
**向上调整**：如果找个节点的权值大于其父节点的权值，则进行交换，重复此过程直到不满足或者到根。

时间复杂度为：O(logn)

## 删除操作
删除操作指删除堆中最大的元素，即删除根节点。
方法是：将根节点与最后一个节点交换，然后删除最后一个节点，最后对根节点进行
**向下调整**：在该节点的子结点中，找到一个最大的，与其交换，重复此过程直到不满足。

时间复杂度：O(logn)

## 增加某个节点的权值
修改后，进行**向上调整**，时间复杂度O(logn)

# 实现
```go
// BinaryPile 大顶堆  
type BinaryPile struct {  
    h []int  
}  
  
func NewBinaryPile(arr []int) *BinaryPile {  
    return &BinaryPile{h: arr}  
}  
  
func (b *BinaryPile) Build() {  
    for i := 1; i < len(b.h); i++ {  
       b.up(i)  
    }   
}  
  
func (b *BinaryPile) Get() int {  
    return b.h[1]  
}  
  
func (b *BinaryPile) Add(val int) {  
    b.h = append(b.h, val)  
    b.up(len(b.h) - 1)  
}  
  
func (b *BinaryPile) Delete() {  
    b.h[0], b.h[len(b.h)-1] = b.h[len(b.h)-1], b.h[0]  
    b.h = b.h[:len(b.h)-1]  
    b.down(0)  
}  
  
func (b *BinaryPile) up(x int) {  
    for b.h[x] > b.h[x/2] && x > 1 {  
       b.h[x], b.h[x/2] = b.h[x/2], b.h[x]  
       x = x / 2  
    }  
}  
  
func (b *BinaryPile) down(x int) {  
    for x*2 <= len(b.h) {  
       if b.h[x*2] > b.h[x] {  
          b.h[x*2], b.h[x] = b.h[x], b.h[x*2]  
          x = x * 2  
       } else if b.h[x*2+1] > b.h[x] {  
          b.h[x*2+1], b.h[x] = b.h[x], b.h[x*2+1]  
          x = x*2 + 1  
       }  
    }  
}  
  
func main() {  
    arr := []int{0, 1, 3, 5, 2}  
    bt := NewBinaryPile(arr)    
    bt.Build()  

    bt.Add(6)  
    fmt.Println(bt.h)  
    fmt.Println(bt.Get())  
}
```