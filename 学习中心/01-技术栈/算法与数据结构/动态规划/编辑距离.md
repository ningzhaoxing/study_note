[题目链接]([72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/?envType=problem-list-v2&envId=7fKmHi2m))

# 解题思路
## 思考递归参数含义
1. `dfs(i,j)` 表示字符串`s`第`i`位置匹配到字符串`t`的第`j`位置时，的最少操作次数。
2. `dfs(i-1,j)` 表示字符串`s`进行了删除操作
3. `dfs(i,j-1)` 表示字符串`s`进行了插入操作
4. `dfs(i-1,j-1)` 表示字符串`s`进行了替换操作

## 思考子问题
- 如果字符串`s`长度为0，`t`长度为n，那么需要的最少操作次数为插入`n`次,即`dfs(0,n) = n`
- 如果字符串`s`长度为n，`t`长度为0，那么需要的最少操作次数为删除`n`次，即`dfs(n,0) = n`
- 假设字符串`"ab"`和字符串`"ca"`，
	`a!=c`:`dfs(1,1)= min(dfs(0,1), dfs(1,0), dfs(0,0)) + 1 = 1`  需要操作一次
	`a==a`:`dfs(1,2) = min(dfs(0,2), dfs(1,1), dfs(0,1)) = 1` 对应的上一步操作分别是：删除操作、插入操作和替换操作。
	`b!=c`:`dfs(2,1) = min(dfs(1,1), dfs(2,0), dfs(1,0) + 1) = 2`
	`b!=a`:`dfs(2,2) = min(dfs(1,2), dfs(2,1), dfs(1,1) + 1) = 2`
	结果为：最小操作次数为`2`.
因为，替换操作会对
# 递归公式
$$
如果s[i] == t[j]: dfs(i,j) = min(dfs(i-1,j)+1, dfs(i,j-1)+1, dfs(i-1,j-1))
$$
$$
如果s[i] != t[j]: dfs(i,j) = min(dfs(i-1,j), dfs(i,j-1), dfs(i-1,j-1)) + 1
$$

# AC代码
```go
func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}

func minDistance(word1 string, word2 string) int {
    n := len(word1)
    m := len(word2)
    
    f := make([][]int, n+1)

    for i := 0; i <= n; i++ {
        f[i] = make([]int, m+1)
        f[i][0] = i
    }

    for i := 0; i <= m; i++ {
        f[0][i] = i
    }

    for i, x := range word1 {
        for j, y := range word2 {
            if x == y {
                f[i+1][j+1] = f[i][j]
            } else {
                f[i+1][j+1] = min(f[i][j+1], min(f[i+1][j], f[i][j])) + 1
            }
        }
    }
    return f[n][m]
}
```