[题目链接]([64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/description/?envType=problem-list-v2&envId=7fKmHi2m))

# 解题思路
## 思考子问题
每次只能向下或向右走

![](Pasted%20image%2020250209150529.png)

- 如果是`1×1`的网格，`dfs(0,0) = dfs(0,0) = grid[0][0]`。
- 如果是`2×2`的网格，`dfs(1,1) = min(dfs(0,1), dfs(1,0)) + grid[1][1]`；
	`dfs(0,1) = dfs(0,0) + grid[0][1]`;`dfs(1,0) = dfs(0,0) + grid[1][0]`

# 递归公式
$$
dfs(i,j) = min(dfs(i-1,j), dfs(i,j-1)) + grid[i][j]
$$
初始化：
```go
f[0][0] = grid[0][0]

for i := 1; i < n; i++ {
    f[0][i] += grid[0][i] + f[0][i-1]
}

for i := 1; i < m; i++ {
    f[i][0] += grid[i][0] + f[i-1][0]
}
```

# AC代码
```go
func minPathSum(grid [][]int) int {

    m := len(grid)

    n := len(grid[0])

    dp := make([][]int, len(grid))

    for i := 0; i < m; i++ {

        dp[i] = make([]int, n)

    }

    dp[0][0] = grid[0][0]

    for i := 1; i < n; i++ {
        dp[0][i] += grid[0][i] + dp[0][i-1]
    }

    for i := 1; i < m; i++ {
        dp[i][0] += grid[i][0] + dp[i-1][0]
    }


    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] += min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
  
    return dp[m-1][n-1]
}
```