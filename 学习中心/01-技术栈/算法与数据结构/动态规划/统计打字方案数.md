[题目链接]([2266. 统计打字方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-number-of-texts/description/))

# 解题思路
组合 + 递推

当按出重复的数字时，其方案数量可以通过递推计算。
比如，当重复按下`n`个字母时，就相当于爬到第`n`阶楼梯。
除了`'7'`和`'9'`之外，只包含3个不同字母，因此可以从`n-1`,`n-2`,`n-3`,这三种状态转移，也就是这三种情况的方案数的总和。
而`'7'`和`'9'`，包含4个不同字母，因此可以从`n-1`,`n-2`,`n-3`,`n-4`，这四种状态转移，也就是这四种情况的方案数的总和。

而Bob收到的字符串是由多个部分的上述相同字符组成的子串组成的，组合后符合乘法原理。
即上述相同字符组成子串方案数的乘积。

## 递归公式
子串方案总数:
`s[i]!='7' && s[i] != '9'`时
$$
dfs(cnt) = dfs(cnt-1) + dfs(cnt-2) + dfs(cnt-3)
$$
`s[i]=='7' || s[i] == '9'`时
$$
dfs(cnt) = dfs(cnt-1) + dfs(cnt-2) + dfs(cnt-3) + dfs(cnt-4)
$$

总方案数
$$
sum = \sum dfs(cnt\{c\})
$$

# AC 代码
```go
const mx = 100005  
  
func countTexts(pressedKeys string) int {  
    m := len(pressedKeys)  
    mod := 1000000007  
  
    f3 := make([]int, mx)  
    f4 := make([]int, mx)  
    f3[0], f3[1], f3[2], f3[3] = 1, 1, 2, 4  
    f4[0], f4[1], f4[2], f4[3] = 1, 1, 2, 4  
  
    for i := 4; i <= m; i++ {  
       f3[i] = (f3[i-1] + f3[i-2] + f3[i-3]) % mod  
       f4[i] = (f4[i-1] + f4[i-2] + f4[i-3] + f4[i-4]) % mod  
    }  
  
    cnt := 0  
    ans := 1  
    for i := 0; i < m; i++ {  
       cnt++  
       if i == m-1 || pressedKeys[i] != pressedKeys[i+1] {  
          if pressedKeys[i] != '7' && pressedKeys[i] != '9' {  
             ans = ans * f3[cnt] % mod  
          } else {  
             ans = ans * f4[cnt] % mod  
          }  
          cnt = 0  
       }  
    }    return ans  
}
```