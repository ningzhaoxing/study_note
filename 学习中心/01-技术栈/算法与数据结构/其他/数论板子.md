# 试除法
## 1. 试除法判定质数
```c++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

## 2. 试除法求质因数
```c++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

## 3. 试除法求约数
```c++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

# 快速幂

## 快速幂+快速乘
```c++
ll ksc(ll a, ll b, ll mod) {
    ll res = 0;
    while(b) {
        if (b & 1) res = (res + a) % mod;
        b >> =1;
        a = a * 2 % mod;
    }
    return res;
}
ll ksm(ll a, ll b,ll mod) {
    ll res=1;
    while(b) {
        if (b & 1) res = ksc(res, a, mod);
        b >> = 1;
        a = ksc(a, a, mod);
    }
    return res;
}
```

## 逆元
计算`a/b%MOD`运用费马引理
$$
b^{M-1}modM=1modM \iff b^{M-2}modM=b^{-1}modM \iff a*b^{M-2}modM=a*b^{-1}modM
$$
那么
$$
a/bmodM=a*b^{M-2}modM
$$

即`res := (a%mod)*ksm(b,mod-2)%mod;`

# 筛法
## 欧拉筛法

```c++
vector<int> getPrim(int n) {
    vector<bool> isPrim(n + 1, false);
    vector<int> prims;

    for (int i = 2; i <= n; i++) {
        if (!isPrim[i]) {
            prims.push_back(i);
        }
        for (int j = 0; j < prims.size(); j++) {
            if (i * prims[j] > n) {
                break;
            }
            isPrim[i * prims[j]] = true;
            if (i % prims[j] == 0) {
                break;
            }
        }
    }
    return prims;
}
```
# 中国剩余定理
![[file-20250509132221657.png]]
求X。
![[file-20250509132241984.png]]