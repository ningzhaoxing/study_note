# CodeRunner 分布式代码执行系统 - 技术文档

## 1. 项目概述

### 1.1 项目简介

CodeRunner 是一个基于 DDD (领域驱动设计) 架构的分布式代码在线运行系统，旨在为博客平台等在线内容平台提供安全、高效的代码执行能力。用户可以直接在博客页面上运行代码示例，无需跳转到外部 IDE 环境。
### 1.2 核心价值

- **实时代码执行**: 提供即时的代码运行结果反馈

- **安全隔离**: 确保用户代码在受控的沙箱环境中运行

- **分布式扩展**: 支持多节点横向扩展，应对高并发场景

- **多语言支持**: 支持主流编程语言的代码执行
### 1.3 应用场景

- 技术博客的代码示例演示

- 在线编程教学平台

- 代码片段测试和验证

- 技术面试的代码评测

## 2. 系统架构

### 2.1 整体架构图

```

┌─────────────────┐

│ 博客系统前端 │ ← 用户提交代码

└────────┬────────┘

│ HTTP + SSE

┌────────▼────────┐

│ 博客系统后端 │

└────────┬────────┘

│ gRPC

┌────────▼─────────────┐

│ codeRunner-server │ ← 腾讯云服务器

│ (任务调度、客户端管理) │

└────────┬─────────────┘

│ WebSocket

┌────┴────┬────────┐

│ │ │

┌───▼──┐ ┌───▼──┐ ┌───▼──┐

│Client1│ │Client2│ │Client3│ ← 内网服务器节点

│(执行) │ │(执行) │ │(执行) │ (实际运行代码)

└───────┘ └───────┘ └───────┘

```

### 2.2 组件说明
#### 2.2.1 codeRunner-server (调度服务器)

- **定位**: 云服务器部署，负责任务调度和客户端管理

- **核心职责**:

- 接收来自博客后端的代码执行请求

- 任务队列管理和优先级调度

- 客户端节点注册与健康监控

- 负载均衡和节点选择

- 执行结果回调推送

#### 2.2.2 codeRunner-client (执行客户端)

- **定位**: 内网服务器部署，负责实际代码执行

- **核心职责**:

- Docker 容器沙箱管理

- 多语言代码编译与执行

- 资源使用监控和限制

- 执行结果收集和上报

#### 2.2.3 共享模块 (shared)

- **定位**: 跨模块共享的定义和工具

- **包含内容**:

- gRPC protobuf 定义

- 共享类型和数据结构

- 通用工具函数

### 2.3 通信机制

| 通信路径 | 协议 | 用途 | 特性 |

|---------|------|------|------|

| 博客后端 → codeRunner-server | gRPC | 同步提交任务 | 高性能、类型安全 |

| codeRunner-server → codeRunner-client | WebSocket | 双向实时通信 | 全双工、低延迟 |

| codeRunner-server → 博客后端 | 异步回调 | 推送执行结果 | 异步、可靠 |

| 博客后端 → 前端 | SSE | 服务器推送 | 单向、实时 |

| Client → Server | 心跳 | 健康状态上报 | 定期、轻量 |


## 3. 技术栈

### 3.1 核心框架与语言

| 组件 | 技术选型 | 版本 | 说明 |

|------|----------|------|------|

| 开发语言 | Go | 1.25.3+ | 高性能、并发友好的系统编程语言 |

| 架构模式 | DDD (领域驱动设计) | - | 清晰的分层架构，关注领域逻辑 |

| RPC 框架 | gRPC | - | 高性能的远程过程调用 |

| 实时通信 | WebSocket | - | 全双工实时通信协议 |

| 服务发现 | ETCD | 3.5+ | 分布式键值存储，用于服务注册发现 |
### 3.2 基础设施

| 组件 | 技术选型 | 说明 |

|------|----------|------|

| 容器化 | Docker | 24.0+，提供代码执行沙箱 |

| 数据库 | MySQL/PostgreSQL | 任务状态持久化存储 |

| 消息队列 | 内置优先级队列 | 任务调度队列实现 |

| 监控 | 自定义资源监控 | CPU、内存、任务数监控 |

### 3.3 客户端依赖

- Docker SDK v28.5.2+ (容器管理)

- gorilla/websocket v1.5.3 (WebSocket客户端)

- OpenTelemetry (分布式追踪)
## 4. 核心功能

### 4.1 任务调度功能

- **任务接收**: 通过 gRPC 接收代码执行请求

- **任务队列**: 优先级队列管理待执行任务

- **负载均衡**: 基于节点负载评分智能调度

- **任务状态管理**: 完整的任务生命周期管理

### 4.2 代码执行功能

- **多语言支持**: Java, Python, C++, Go, JavaScript

- **沙箱隔离**: Docker 容器提供安全执行环境

- **资源限制**: CPU、内存、执行时间限制

- **结果收集**: 标准输出、错误输出、执行状态、资源使用

### 4.3 客户端管理功能

- **自动注册**: 客户端启动时自动向服务器注册

- **心跳监控**: 定期上报健康状态和负载信息

- **断线重连**: 自动重连机制，指数退避策略

- **负载计算**: 基于 CPU、内存、任务数计算负载评分

### 4.4 安全功能

- **容器隔离**: 每个任务在独立容器中执行

- **网络隔离**: 默认禁用容器网络访问

- **文件隔离**: 只读文件系统，防止越权访问

- **资源限制**: 防止资源耗尽攻击

- **代码检查**: 基础的安全代码检查

## 5. DDD 分层架构详解

### 5.1 架构分层原则

CodeRunner 严格遵循 DDD 分层架构，确保领域逻辑与技术实现的分离。

#### 5.1.1 领域层 (Domain Layer)

- **位置**: `internal/domain/`

- **职责**: 核心业务逻辑和规则

- **特点**: 不依赖任何外部框架，纯业务逻辑

- **内容**:

- 聚合根 (Aggregate Root): ExecutionTask, ClientNode

- 值对象 (Value Object): TaskId, Code, ResourceLimit

- 领域服务 (Domain Service): ITaskScheduler

- 仓储接口 (Repository Interface)

#### 5.1.2 应用层 (Application Layer)

- **位置**: `internal/application/`

- **职责**: 业务流程编排，协调领域对象

- **特点**: 无业务逻辑，只做流程编排

- **内容**:

- 应用服务 (Application Service): CodeExecutionAppService

- 命令对象 (Command): SubmitTaskCommand

- DTO (Data Transfer Object): TaskDTO

- 领域事件 (Domain Event): TaskCompletedEvent

#### 5.1.3 基础设施层 (Infrastructure Layer)

- **位置**: `internal/infrastructure/`

- **职责**: 技术实现和外部集成

- **特点**: 实现领域层定义的接口

- **内容**:

- 仓储实现: TaskRepositoryImpl

- 数据库访问: MySQL/PostgreSQL

- 消息队列: 优先级队列实现

- 外部服务: gRPC, WebSocket, ETCD 客户端


#### 5.1.4 接口层 (Interface Layer)

- **位置**: `internal/interfaces/`

- **职责**: 对外提供 API，处理协议细节

- **特点**: 数据格式转换，协议处理

- **内容**:

- gRPC 接口实现

- HTTP 接口 (监控、健康检查)


### 5.2 依赖关系

```

┌─────────────────┐

│ Interfaces │ ← 对外 API (HTTP/gRPC)

└────────┬────────┘

↓ 依赖注入

┌────────────────┐

│ Application │ ← 业务流程编排

└────────┬───────┘

↓ 依赖注入

┌────────────────┐

│ Domain │ ← 核心业务逻辑（不依赖其他层）

└────────────────┘

↑ 接口实现

┌────────┴───────┐

│Infrastructure │ ← 技术实现（实现领域层接口）

└────────────────┘

```

### 5.3 代码组织原则

1. **内部包隔离**: `internal/` 目录下的代码只能被本模块引用

2. **公共包暴露**: `pkg/` 目录下的代码可以被外部模块引用

3. **领域层独立**: 领域层不依赖任何外部框架

4. **依赖倒置**: 通过接口定义依赖，基础设施层实现

5. **单一职责**: 每个聚合根管理自己的业务规则

## 6. 核心流程

### 6.1 代码执行流程

```

1. 用户在博客前端提交代码

↓

2. 博客后端通过 gRPC 调用 codeRunner-server

↓

3. codeRunner-server 创建 ExecutionTask 聚合根

↓

4. 任务进入优先级队列等待调度

↓

5. 调度器选择负载最低的 client 节点

↓

6. 通过 WebSocket 发送任务到选中的 client

↓

7. client 从容器池获取对应语言的 Docker 容器

↓

8. 在容器内创建独立工作目录 (/workspace/task-{taskId})

↓

9. 将代码文件复制到工作目录

↓

10. 执行编译（如需要）和运行

↓

11. 收集输出、错误信息和资源使用

↓

12. 清理工作目录，容器保持运行

↓

13. client 通过 WebSocket 返回结果给 server

↓

14. server 更新任务状态，通过异步回调推送结果给博客后端

↓

15. 博客后端通过 SSE 推送给前端

↓

16. 用户看到执行结果

```

  

### 6.2 客户端注册流程

```

1. client 启动，连接 server 的 WebSocket 端点

↓

2. server 生成唯一 clientId，创建 ClientNode 聚合根

↓

3. server 将 client 信息注册到 ETCD

↓

4. client 启动心跳定时器，定期发送负载信息

↓

5. server 更新 ClientNode 的负载状态

↓

6. 调度器根据负载评分选择执行节点

↓

7. 断线时，server 从 ETCD 注销 client

```

  

### 6.3 容器池管理流程 (客户端)

```

服务启动

↓

检查宿主机是否存在对应语言容器

↓

├─→ 存在且运行中 → 直接使用

├─→ 存在但已停止 → 启动容器

└─→ 不存在 → 拉取镜像并创建容器

↓

容器保持运行状态（饿汉模式）

↓

任务执行时在容器内创建独立工作目录

↓

执行完成后清理工作目录，容器继续运行

↓

服务关闭时优雅停止所有容器

```

  

## 7. 负载均衡策略

  

### 7.1 负载评分算法

系统采用加权评分算法计算客户端节点负载：

  

```go

loadScore = (0.4 * cpuUsage) +

(0.4 * memoryUsage) +

(0.2 * runningTasks / maxTasks)

```

  

**参数说明**:

- `cpuUsage`: CPU 使用率百分比 (0-100)

- `memoryUsage`: 内存使用率百分比 (0-100)

- `runningTasks`: 当前运行任务数

- `maxTasks`: 最大并发任务数配置

  

### 7.2 调度策略

1. **负载最低优先**: 选择负载评分最低的节点

2. **健康检查**: 只选择心跳正常的节点

3. **容量检查**: 确保节点未达到最大任务限制

4. **故障转移**: 节点故障时自动转移到其他节点

  

### 7.3 动态调整

- 心跳间隔: 30秒

- 负载更新: 每次心跳时更新

- 调度决策: 每次任务分配时实时计算

  

## 8. 安全措施

  

### 8.1 容器安全

| 措施 | 实现方式 | 安全效果 |

|------|----------|----------|

| 容器隔离 | Docker 容器 | 进程、文件系统隔离 |

| 资源限制 | Docker --cpus, --memory | 防止资源耗尽攻击 |

| 网络隔离 | --network none | 禁止外部网络访问 |

| 用户权限 | 非 root 用户运行 | 权限最小化 |

| 文件系统 | 只读挂载，临时工作目录 | 防止文件系统篡改 |

  

### 8.2 执行安全

- **时间限制**: 严格限制代码执行时间

- **内存限制**: 防止内存溢出攻击

- **进程限制**: 限制容器内进程数量

- **系统调用过滤**: 限制危险系统调用

  

### 8.3 通信安全

- **WebSocket 加密**: 建议使用 WSS (WebSocket Secure)

- **gRPC 认证**: 支持 TLS 加密和身份验证

- **心跳验证**: 防止非法客户端接入

  

## 9. 性能优化

  

### 9.1 容器池模式

**设计模式**: 饿汉模式 + 容器复用

  

**性能优势**:

- **首次执行**: 3-5秒 (包含镜像拉取时间)

- **后续执行**: 0.1-0.3秒 (容器已就绪)

- **性能提升**: 10-20倍 相比每次创建容器

  

**实现机制**:

1. 服务启动时预创建所有语言容器

2. 容器持久运行，多任务共享

3. 通过工作目录实现任务隔离

4. 避免频繁的容器创建销毁开销

  

### 9.2 并发控制

- **客户端并发限制**: 限制每个客户端同时执行的任务数

- **队列管理**: 优先级队列确保重要任务优先执行

- **连接池**: WebSocket 连接复用

  

### 9.3 资源监控

- **实时监控**: CPU、内存使用率监控

- **动态调整**: 根据负载动态调整可接受任务数

- **预警机制**: 资源使用超过阈值时告警

  

## 10. 部署与运行

  

### 10.1 环境要求

**Server 端:**

- Go 1.25.3+

- ETCD 3.5+

- MySQL 8.0+ / PostgreSQL 14+

- 建议配置: 2核4G+

  

**Client 端:**

- Go 1.25.3+

- Docker 24.0+

- 建议配置: 4核8G+ (根据并发需求调整)

  

### 10.2 部署架构

```

生产环境建议部署:

- 1个 Server 节点 (可多实例部署，通过负载均衡器暴露)

- N个 Client 节点 (根据负载横向扩展)

- 1个 ETCD 集群 (3节点保证高可用)

- 1个 MySQL/PostgreSQL 数据库

```

  

### 10.3 启动步骤

**启动 Server:**

```bash

cd codeRunner-server

go mod tidy

cd cmd/server

go run main.go --config configs/config.yaml

```

  

**启动 Client:**

```bash

cd codeRunner-client

go mod tidy

cd cmd/client

go run main.go --server-url ws://server-host:8080/ws

```

  

### 10.4 配置说明

**Server 配置示例 (config.yaml):**

```yaml

server:

grpc_port: 50051

websocket_port: 8080

http_port: 8081

  

database:

type: "mysql"

dsn: "user:password@tcp(localhost:3306)/coderunner"

  

etcd:

endpoints: ["localhost:2379"]

dial_timeout: 5s

  

scheduler:

max_queue_size: 1000

worker_count: 10

```

  

**Client 配置示例:**

```yaml

server_url: "ws://localhost:8080/ws"

max_concurrent_tasks: 5

heartbeat_interval: 30

reconnect:

base_interval: 5

max_interval: 60

max_retries: 10

```

  

## 11. 监控与运维

  

### 11.1 监控指标

| 指标类别 | 具体指标 | 监控方式 |

|----------|----------|----------|

| 系统健康 | 服务可用性、心跳状态 | 健康检查端点 |

| 性能指标 | QPS、响应时间、错误率 | Prometheus + Grafana |

| 资源使用 | CPU、内存、磁盘、网络 | 节点监控 |

| 业务指标 | 任务数、成功率、平均执行时间 | 自定义指标 |

  

### 11.2 日志系统

- **访问日志**: HTTP/gRPC 请求日志

- **业务日志**: 任务执行关键步骤日志

- **错误日志**: 异常和错误详情

- **审计日志**: 安全相关操作记录

  

### 11.3 健康检查

- **HTTP 健康端点**: `GET /health`

- **gRPC 健康检查**: gRPC health check protocol

- **就绪检查**: `GET /ready`

- **存活检查**: `GET /live`

  

## 12. 扩展性设计

  

### 12.1 水平扩展

- **无状态 Server**: Server 节点可水平扩展

- **Client 弹性**: 根据负载动态增减 Client 节点

- **数据库分片**: 支持任务数据分片存储

  

### 12.2 功能扩展

- **插件化语言支持**: 通过实现 Runtime 接口添加新语言

- **自定义沙箱**: 支持不同的沙箱实现 (Docker, gVisor, etc.)

- **认证授权**: 可集成 OAuth2、JWT 等认证方式

  

### 12.3 性能扩展

- **缓存层**: 可添加 Redis 缓存高频数据

- **CDN 集成**: 支持大型依赖文件通过 CDN 分发

- **异步处理**: 耗时操作异步化处理

## 14. 故障处理与恢复

  

### 14.1 常见故障场景

| 故障类型 | 检测方式 | 恢复策略 |

|----------|----------|----------|

| Client 断线 | 心跳超时 | 自动重连，指数退避 |

| 容器异常 | 执行失败 | 重启容器，重新执行 |

| 数据库故障 | 连接失败 | 重试机制，降级处理 |

| 网络分区 | 通信超时 | 超时重试，故障转移 |

  

### 14.2 容错机制

- **重试策略**: 网络调用自动重试

- **断路器模式**: 防止级联故障

- **降级策略**: 非核心功能可降级

- **超时控制**: 所有外部调用设置超时

  

## 15. 开发规范

  

### 15.1 代码规范

1. **遵循 DDD 原则**: 领域层不依赖外部框架

2. **依赖倒置**: 通过接口定义依赖

3. **单一职责**: 每个包职责清晰

4. **测试覆盖**: 核心业务逻辑需要单元测试

5. **错误处理**: 使用 Go 的错误处理机制，不使用 panic

  

### 15.2 提交规范

- **提交信息格式**: `type(scope): description`

- **类型说明**:

- `feat`: 新功能

- `fix`: bug修复

- `docs`: 文档更新

- `refactor`: 代码重构

- `test`: 测试相关

- `chore`: 构建过程或辅助工具变动

  

### 15.3 分支策略

- `main`: 生产环境分支

- `develop`: 开发主干分支

- `feature/*`: 功能开发分支

- `hotfix/*`: 紧急修复分支

  

## 16. 附录

  

### 16.1 术语表

| 术语 | 解释 |

|------|------|

| ExecutionTask | 代码执行任务聚合根 |

| ClientNode | 客户端节点聚合根 |

| Sandbox | 代码执行沙箱环境 |

| Runtime | 特定语言的编译运行环境 |

| 负载评分 | 节点负载的量化指标 |

### 16.3 参考资料

- [DDD (Domain-Driven Design) 概念](https://domainlanguage.com/ddd/)

- [Docker 官方文档](https://docs.docker.com/)

- [gRPC 官方文档](https://grpc.io/docs/)

- [ETCD 文档](https://etcd.io/docs/)

---


**文档版本**: v1.0

**最后更新**: 2026-02-21

**维护者**: CodeRunner 开发团队

  

> 注意: 本文档会随着项目发展持续更新，请关注最新版本。