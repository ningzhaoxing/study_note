### **一、对象分类与核心特征**
| **类型**   | **可变性** | **依赖注入方式** | **关键特征**        |
| -------- | ------- | ---------- | --------------- |
| **服务对象** | 不可变     | 构造函数注入     | 无状态、可复用、无Setter |
| **值对象**  | 不可变     | 不依赖外部服务    | 匿名、可替换、封装验证逻辑   |
| **实体**   | 可变      | 方法参数传入依赖   | 有唯一标识、通过方法修改状态  |
| **DTO**  | 可变      | 无需构造方法     | 纯数据结构、属性全公开     |

---

### **二、创建对象的设计规范**
#### **1. 服务对象（不可变）**
- **依赖注入规则**：
  - **仅构造函数注入**：禁止Setter注入，避免对象处于不完整状态。
  - **声明实际依赖**：直接注入所需服务，而非通过ServiceLocator间接获取。
  - **无可选依赖**：若依赖可选，注入"占位对象"（如空实现NullLogger）。
- **构造器约束**：
  - 仅做参数校验与赋值，不包含业务逻辑。
  - 依赖项必须通过构造函数参数显式声明。
- **复杂依赖处理**：
  - 将系统调用（如数据库、API）抽象为接口，通过依赖注入。
  - 示例：注入`IPaymentGateway`而非在服务内直接调用支付API。

#### **2. 值对象与实体（其他对象）**
- **值对象设计**：
  - **从复合值提取**：如`Money(amount, currency)`代替分离的金额和货币类型。
  - **封装验证**：构造函数内验证数据有效性（如金额非负），确保对象始终合法。
  - **避免暴露内部**：不提供`ToString()`/`ToInt()`，除非必要。
- **实体设计**：
  - **无依赖注入构造函数**：依赖项通过方法参数传入（如`user.ChangePassword(hasher, newPassword)`）。
  - **立即验证**：遇到无效参数直接抛出异常（非异常列表）。
- **DTO设计**：
  - 属性全公开，可包含原始类型或其他DTO。
  - 允许属性填充器（如JSON反序列化到对象）。
  - 通过`Validate()`收集多个错误后统一抛出。

#### **3. 通用创建原则**
- **禁止反射填充**：除DTO外，禁止用数据数组反射填充对象属性。
- **测试重点**：
  - 测试构造函数在无效输入时是否失败。
  - 仅当需要暴露数据时才添加Getter。

---

### **三、操作对象的规范**
#### **1. 状态变更**
- **不可变对象（值对象/服务）**：
  - 修改时返回新实例（副本）。
  - 示例：`Position.ToTheLeft(steps)`返回新`Position`对象。
- **可变对象（实体）**：
  - 通过**修改方法**改变状态（如`Order.Ship()`）。
  - 方法名使用`动词`格式（如`moveTo()`, `updateStatus()`）。

#### **2. 防止无效状态**
- **修改器的责任**：
  - 与构造函数一样验证输入有效性。
  - 检查状态迁移是否合法（如"已支付订单不可取消"）。
- **验证模式**：
  ```go
  func (d *TriggerDraft) UpdateWith(validated *ValidatedTriggerDraft) {
      // 使用预验证对象确保输入合法
  }
  ```

#### **3. 对象比较**
- **测试代码**：用专用函数（如`assertEquals()`）比较对象。
- **生产代码**：实现`Equals()`方法（值对象按属性比较，实体按ID比较）。

#### **4. 变更追踪**
- **领域事件**：实体状态变化时发布事件（如`OrderPaidEvent`），解耦业务逻辑。

---

### **四、方法设计模板**
```go
[scope] function methodName(type name, ...): [return-type] {
    // 1. 前置条件检查
    if (inputInvalid) throw ValidationException();

    // 2. 处理失败场景（如并发冲突）
    if (stateInvalid) throw DomainException();

    // 3. 核心逻辑（成功路径）
    performOperation();

    // 4. 更新状态/发布事件
    this.status = newStatus;
    publishEvent();

    // 5. 后置条件检查（可选）
    assert invariantsHold();

    return [result];
}
```

---

### **关键原则总结**
| **主题**    | **规则**                                   |
| --------- | ---------------------------------------- |
| **不可变性**  | 服务对象、值对象不可变；实体可变但需受控修改。                  |
| **依赖管理**  | 服务：构造函数注入；实体：方法参数传入依赖。                   |
| **验证时机**  | 值对象/实体：创建时立即验证；DTO：通过`Validate()`批量收集错误。 |
| **状态安全**  | 修改方法需校验参数和状态迁移逻辑（如"已支付订单不可取消"）。          |
| **防御性设计** | 方法模板强制前置条件检查 + 失败场景优先处理。                 |
| **抽象层级**  | 将系统调用（时钟、存储）抽象为显式依赖，提升可测试性。              |
