# 问题

你在设计数据库时提到“符合三范式和实际需求”，
能否举例说明某个场景下需要在范式与性能之间做权衡？如果查询性能因三范式设计而下降，你会如何优化？

# 回答

> 回忆数据库设计三大范式：
> 1. 原子性：数据库表属性要保证原子性，不可分割。
> 2. 唯一性：满足第一范式的前提下，消除非主属性对主属性的部分依赖。
> 3. 独立性：消除传递依赖。

比如，在查询帖子的时候，同时也是需要查询当前帖子对应的用户名称、头像等数据，查询时就需要通过`userId`联合用户表。当数据量特别大的时候，频繁的连表查询会造成很大的查询延迟。

找个时候，为了消除依赖传递，但造成了性能的损失。找个时候最简单的方案就是在帖子表中添加需要的用户属性，这样就可以避免连表查询。但是会污染帖子表，而且如果较难维护，而且可能还需要保证帖子表的冗余字段和用户表的数据一致性等问题。

我觉得更好的一种方案是，可以使用redis缓存，将`userId`作为key，冗余字段存储到对应的value，通过缓存加速的方式提高性能，当然需要解决的问题就是mysql与redis的缓存一致性问题。

# 拓展问题

## Preload n+1问题

如果帖子表需要关联用户表（如查询发帖人信息），GORM的Preload方法在大量数据时可能产生性能问题（如N+1查询），如何通过JOIN或批量查询优化？

## 回答

preload产生所谓的n+1问题就是说，preload会再著查询之后会生成独立的sql，通过额外的查询来加载关联数据。比如说，加载一个`users`和其关联的`orders`，preload会先加载`users`的所有数据，然后为每一个`user`查询其`orders`，总共查询了n+1次。如果在关联数据较多性能就会变低。

而通过Joins连接表的话，它会将主表和关联表的数据合并成一个表查询，可能会造成数据冗余，需要进行去重。但因为它只需要查询一次的缘故，当关联数据较多的时候，性能是要比preload更好的。





## 模糊查询优化策略

创建全文索引：

```mysql
create table posts (
	id int primary key,
	content text,
	fulltext key ft_content (content)
) engine=innodb;

-- 添加索引
alter table articles add fulltext ft_content(content);
```

全文检索语法：

```mysql
-- 自然语言模式
select * from articles
where match(content) against('数据库优化')

-- 布尔模式(精确匹配)
select * from articles
where match(content) against('+MySQL -Oracle' in boolean mode);
```

