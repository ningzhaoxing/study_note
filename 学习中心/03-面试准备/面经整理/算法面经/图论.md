# 拓扑排序
将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。
## 构造过程
1. 从图中选择一个入度为零的点
2. 输出该顶点，从图中删除此顶点及其所有的出边

重复上面两步，直到所有顶点输出，拓扑排序完成。
如果图中不存在入读为零的点，则说明该图是有环图，拓扑排序无法完成。

> 初始将所有入度为0的点加入集合S，并随机选择一个点加入集合L，并删除该点的所有出边，如果存在入度为0的点，则加入集合S。
> 不断重复该过程，直到集合S为空。然后检查图中是否还存在边，若存在，则说明该图为有环图。

# 最小生成树
无向连通图的 **最小生成树** 就是边权和最小的生成树。
## Kruskal算法
贪心地将所有边按照边权进行排序，从小到达依次加入，如果某次加边产生了环，则跳过这条边，直到加入了 n-1 条边。

## Prim算法
贪心的不断加点，每次加点都加距离最小的点，以及用新的边更新到其它节点的距离。

# 最短路
## Floyd
任何图的全源最短路算法。
定义`f[k][x][y]`，表示只允许经过节点 1 到 k ，节点x到y的最短路长度。
然后枚举所有情况，直到枚举到经过所有点后，计算出`f[n][x][y]`的距离。
递推公式：
`f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y])`

`f[x][y] = min(f[x][y], f[x][k]+f[k][y])`
## Dijkstra
**非负权图**单源最短路算法。
初始化`dis(s)=0`，其它点的`dis`为无穷。
将节点分成两个集合，已确定最短路的点集S，以及未确定的点集T。
从T集合中选取最短路径的节点，移入S集合，并更新该点的最短距离。
重复操作，直接T集合为空。