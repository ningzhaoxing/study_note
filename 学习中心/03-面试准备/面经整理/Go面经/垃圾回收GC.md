垃圾回收就是把不再需要的内存块及时清理，以便再次被分配使用。
# Golang垃圾回收
## 垃圾回收原理
golang采用***标记-清除***垃圾回收算法中的**三色标记法**。
标记-清除算法
> 从根变量开始遍历所有引用的对象，引用的对象标记为"被引用"，没有被标记的进行回收

- 优点：解决了引用计数的缺点。
- 缺点：需要STW(Stop The World)，即要暂时停掉程序运行。
- 代表语言：Golang（其采用三色标记法）

简单来说，垃圾回收的核心是标记出哪些内存还在使用中(即被引用到)，哪些内存不再使用了(即未被引用)，把未被引用的内存回收，以供后续内存分配时使用。

![[20250122161452.png]]
上图，内存块中1、2、4号位上的内存块已被分配(1表示已被分配，0未分配)。
变量a、b为一个指针，指向内存的1、2号位。
内存块4曾被分配过，但现在没有任何对象引用了，就需要被回收掉。

### 过程
- 从`root`对象开始扫描
- 把`root`对象引用的内存标记为“被引用”
- 若内存块中存放的是指针，则还需要递归进行标记
- 保留被标记的内存，未被标记的全部标识为**未分配**，即完成了回收

## 内存标记（Mark）
在`span`数据结构中的位图`allocBits`表示每个内存块的分配情况；
位图`gcmarkBits`用于标记内存块被引用的情况。
![[20250122165545.png]]
`allocBits`和`gcmarkBits`数据结构是完全一样的。
内存标记结束即内存回收完成，会将`allocBits`指向`gcmarkBits`，则代表标记过的才是存活的。

### 三色标记法
需要一个标记队列来存放待标记的对象。从该标记队列中取出对象，并将该对象的引用状态标记在`span`的`gcmawrkBits`，然后把该对象引用的其他对象放入到队列中。
>三色标记法对应了垃圾回收过程中对象的三种状态：
>- 灰色：对象还在标记队列中等待
>- 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
>- 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）

具体的标记算法如下：

例如，当前内存中有A~F一共6个对象，根对象a,b本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而B对象又引用了对象D，则GC开始前各对象的状态如下图所示:
![[20250122172820.png]]
初始状态下所有对象都是白色的。

接着开始扫描根对象a、b:
![[20250122172831.png]]
由于根对象引用了对象A、B，那么A、B变为灰色对象。
然后，分析灰色对象。分析A时，它没有引用其他对象，直接变为黑色对象；分析B时，B引用了D，则B转为黑色对象的同时还需将D转为灰色对象。
![[20250122173025.png]]
分析D，由于D没有引用其他对象，直接转为黑色。灰色对象为空，标记过程结束。
![[20250122173224.png]]

最终，黑色对象会被保留下来，白色对象会被回收。

## Stop The World?
Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。
STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。

为了缩短STW的时间，Golang不断优化垃圾回收算法，这种情况得到了很大的改善。
### 为什么需要STW
如果不暂停程序，如果在垃圾回收标记阶段，程序的逻辑改变了对象的引用关系，会影响标记结果的正确性。
下面举一个例子
![[20250124195826.png]]
![[20250124195832.png]]
![[20250124195836.png]]
![[20250124195849.png]]
![[20250124195854.png]]


- 条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**
- 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**

当以上两个条件同时满足时, 就会出现对象丢失现象。

# 垃圾回收优化
为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是**STW的过程有明显的资源浪费，对所有的用户程序都有很大影响**.
如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？  

> 答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.

我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式。
### (1) “强-弱” 三色不变式
- 强三色不变式

不存在黑色对象引用到白色对象的指针
![[20250124200456.png]]
- 弱三色不变式

所有被黑色对象引用的白色对象都处于灰色保护状态.

![[20250124200539.png]]


为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.

## 屏障机制

### (2) 插入屏障(写屏障)
`具体操作`: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

`满足`: **强三色不变式**. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

插入屏障机制只使用在堆空间对象的操作中,不能在栈空间中使用.

下面为插入屏障机制的执行流程
![[20250124201135.png]]
![[20250124201140.png]]
![[20250124201145.png]]
![[20250124201149.png]]

![[20250124201158.png]]
![[20250124201204.png]]
但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9)(**这个栈上的白色对象可能会逃逸到堆上，导致被清除**). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.

### (3) 删除屏障
`具体操作`: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
`满足`: **弱三色不变式**. (保护灰色对象到白色对象的路径不会断)

以下为删除屏障机制的过程:
![[20250124202121.png]]

![[20250124202125.png]]
![[20250124202134.png]]
![[20250124202139.png]]
![[20250124202143.png]]
![[20250124202148.png]]
![[20250124202153.png]]

这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

## Go1.8的混合写屏障机制

插入写屏障和删除写屏障的短板：

- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；  
- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。  

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

### (1) 混合写屏障规则
`具体操作`:

1、GC开始将**栈上的对象**全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色。

3、被删除的对象标记为灰色。

4、被添加的对象标记为灰色。


该屏障技术不在栈上使用,因为需要保证栈的运行效率

### (2) 混合写屏障的具体场景分析
#### GC开始：扫描栈区，将可达对象全部标记为黑
![[20250124204321.png]]
![[20250124204326.png]]
#### 场景一： 对象被一个堆对象删除引用，成为栈对象的下游
![[20250124204848.png]]
![[20250124204853.png]]
#### 场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游
![[20250124204908.png]]
![[20250124204913.png]]
![[20250124204918.png]]
#### 场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游
![[20250124204933.png]]
![[20250124204942.png]]
![[20250124204946.png]]
#### 场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游
![[20250124205000.png]]
![[20250124205004.png]]
![[20250124205008.png]]

Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。

## 辅助GC(Mutator Assist)
为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。

# 垃圾回收触发时机
## 内存分配量达到阈值触发GC
默认情况下，最长2分钟触发一次GC，这个间隔在`src/runtime/proc.go:forcegcperiod`变量中被声明：
```
// forcegcperiod is the maximum time in nanoseconds between garbage
// collections. If we go this long without a garbage collection, one
// is forced to run.
//
// This is a variable for testing purposes. It normally doesn't change.
var forcegcperiod int64 = 2 * 60 * 1e9
```
## 手动触发
程序代码中也可以使用`runtime.GC()`来手动触发GC。这主要用于GC性能测试和统计。

# GC性能优化
GC性能与对象数量负相关，对象越多GC性能越差，对程序影响越大。

所以GC性能优化的思路之一就是***减少对象分配个数***，比如对象复用或使用大对象组合多个小对象等等。

另外，由于内存逃逸现象，有些隐式的内存分配也会产生，也有可能成为GC的负担。

[golang gc 三色原理 挑战全网 - 知乎](https://zhuanlan.zhihu.com/p/709672524?utm_psn=1799807786491723776)