## Golang调度器的由来
### 1.协程提高CPU利用率
#### 线程分为用户态和内核态；协程其实就是用户态的线程。
![[Pasted image 20250328201246.png]]
#### 协程和线程的映射关系
##### N:1关系
> N个协程绑定一个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常轻量快速。但是也有很大的缺点，1个进程的所有协程都绑定在1个线程上。
> 
> 缺点：
> 某个程序用不了硬件的多核加速能力。
> 一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力。
![[Pasted image 20250328204828.png]]

##### 1:1关系
> 1个协程绑定一个线程，这种最容易实现。协程的调用都由CPU完成了，不存在N:1缺点
> 缺点：
>  协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。
>  ![[Pasted image 20250328211719.png]]

##### M:N关系
> M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上两种模型的缺点，但实现起来最为复杂
![[file-20250404174340800.png]]


协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。

### Go语言的协程goroutin
> **Go为了提供更容易使用的并发方法，使用了goroutine和channel**。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。
> Go中的协程非常轻量，只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多的内容，runtime会自动为goroutine分配。
> 
> 特点：
>      占用内存更小,调度更灵活

### 被废弃的goroutine调度器
![[Pasted image 20250329093030.png]]
首先M想要执行，放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。

>缺点
>	1.创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。
>	2.M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G'，为了继续执行G，需要把G'交给M‘执行，也就造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他的M‘。
>	3.系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。 

## Goroutine调度器的GMP模型的设计思想
引入了processor，它包含了运行goroutine的资源，如果线程想运行gotoutine，必须先 获取P，P中包含了可运行的G队列。
### GMP模型
>	在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。
>	![[Pasted image 20250329102626.png]]
>	1.全局队列：存放等待运行的G
>	2.P的本地队列：同全局队列类似，存放的也是等待运行的的G，存放的数量有限，不超过256个。新建G’时，G‘优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
>	3.P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。
>	4.M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，`M`也会尝试从全局队列哪一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。 

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。

#### P和M的个数问题
- P的数量：由启动时环境变量`$GOMAXPROCS`或者是由`runtime`的方法`GOMAXPROCS()`决定。这意味着在程序执行的任意时刻都只有`$GOMAXPROCS`个goroutine在同时运行。
- M的数量：go语言本身的限制:go程序在启动中，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug中的SetMaxThreads函数，设置M的最大数量
- 一个M阻塞了，会创建新的M。
M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建个很多个M出来。
#### P和M何时会被创建
- P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。
- M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。
### 调度器的设计策略
`复用线程`:避免频繁的创建、销毁线程，而是对线程的复用。
#### work stealing机制
当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
#### hand off机制
当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

`利用并行`：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行，`GOMAXPROCS`也限制了并发的程度，比如`GOMAXPROCS =核数/2`，则最多利用了一半的CPU核进行并行。
`抢占`：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU10ms，防止其他goroutine要饿死，这就是goroutine不同于coroutine的一个地方。
`全局G队列`：在新的调度器中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。
### go func()调度流程

![[Pasted image 20250329153608.png]]
- 1.我们通过go func()来创建一个goroutine；
- 2.有两个存储G的队列，一个是局部调度器P的本地队列，一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中。
- 3.G只能运行在M中，一个M必须持有一个P，M与P是1:1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行。
- 4.一个M调度G执行的过程是一个循环机制；
- 5.当M执行某一个G时候如果发生了syscall或者其他阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach),然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；
- 6.当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入全局队列中。
### 调度器的生命周期
![[Pasted image 20250329171142.png]]

`特殊的M0和G0`
#### M0
>`M0`时启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G，在之后M0就和其他的M一样了。

#### G0
>`G0`是每次启动 一个M都会第一个创建的goroutine，G0仅用于负责调度的G，G0不指向任何可执行的函数，每个M都会都一个自己的G0。在调度或系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。

#### 示例：
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello world")
}
```
- runtime创建最初的线程m0和goroutine g0，并把两者关联起来。![[Pasted image 20250329201447.png]]

- 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。
- 示例代码中的main函数是`main.main`，`runtime`中也有1个main函数------`runtime.main`，代码经过编译后，`runtime.main`会调用`main.main`，程序启动时会为`runtime.main`创建goroutine，称它为main goroutine，然后把main goroutine加入到P的本地队列。
- 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
- G拥有栈，M根据G中的栈信息和调度信息设置运行环境
- M运行G
- G退出，再次回到M获取可运行的G，这样重复下去，直到`main.main`退出，`runtime.main`执行Defer和Panic处理，或调用`runtime.exit`退出程序
## Go调度器调度场景过程全解析
### (1)场景1
>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P的本地队列。
>- **局部性原则**：Go调度器会尽量让新创建的Goroutine运行在创建它的P上，以减少上下文切换的开销。
>![[Pasted image 20250329203141.png]]

### (2)场景2
>	G1运行完成后(函数:goexit)，M上运行的goroutine切换为G0,G0负责调度时协程的切换
>	(函数：schedule)。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。
>	![[Pasted image 20250329203956.png]]

### (3)场景3
>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G(G3,G4,G5)已经加入p1的本地队列，P1本地队列满了。
>![[Pasted image 20250329205851.png]]

### (4)场景4
>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建的G转移到全局队列)
>(实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列)
>![[Pasted image 20250329212102.png]]
>这些G被转移到全局队列时，会被打乱顺序。所以G3，G4，G7被转移到全局队列。

### (5)场景5
>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。
>![[Pasted image 20250329213141.png]]
>G8加入到P1的本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。

### (6)场景6
>规定在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。
>![[Pasted image 20250329213732.png]]
>假定G2唤醒了M2，M2绑定了P2，并运行了G0，但P2本地队列没有G,M2此时为自旋线程(没有G但为运行状态的线程，不断寻找G)。

### (7)场景7
>M2尝试从全局队列(简称”GQ“)取一批G放到P2的本地队列。M2从全局队列取的G数量符合下面公式
>
```GO
n =  min(len(GQ) / GOMAXPROCS +  1,  cap(LQ) / 2 )
```
至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是**从全局队列到P本地队列的负载均衡**。
![[Pasted image 20250331143233.png]]
假定我们场景中一共有4个P(GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用)。
所以M2只能从全局队列取1个G(即G3)移动P2本地队列，然后完成从G0到G3的转换，运行G3。
### (8)场景8
假设G2一直在M1上运行，经过两轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了；那M就要执行偷取work stealing(偷取)；从其他有G 的P那里偷取一半G过来，放到自己的P的本地队列。P2从P1的本地队列尾部偷取一半的G![[Pasted image 20250331150147.png]]
### (9)场景9
G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。
![[Pasted image 20250331150405.png]]
#### 为什么让m3和m4自旋？
自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU。为什么不销毁现场，来节约CPU资源。：因为创建和销毁 也会使CPU浪费时间，为了保证当有新的goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑过多的自旋线程是浪费CPU，所以系统中最多有`GOMAXPROCS`个自旋的线程，其余空闲线程会休眠。
### (10)场景10
假定当前除了M3和M4为自旋线程，还有M5和M6为空闲线程(`在这里没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远都是M>=P,大部分都是M在抢占运行的P`)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行一下判断:如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立即唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的P。本场景中,P2本地队列有G9，可以和其他空闲的线程M5绑定。
![[Pasted image 20250331153035.png]]
### (11)场景11
G8创建了G9，加入G8进行了非阻塞系统调用
![[file-20250404174239978.png]]
M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列，M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。
## 总结
Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生(强大)并发能力。Go调度本质是把大量的goroutine分配到少量的线程上去执行，并利用多核并行，实现更强大的并发。

## 61次调度机制
>这个机制是Go调度器中非常重要的设计，它体现了调度器在公平性和负载均衡上的考量。这个行为属于Go调度器的work-stealing机制的一部分，我们可以从以下几个层面来理解:

### 调度周期的计数器(schedtick)
- Go的每个P(逻辑处理器)都有一个计数器`schedtick`，每次调度一个goroutine时，这个计数器会递增。
- 当`schedtick%61==0`时(即每调度61次)，调度器会主动检查全局队列(globrunqget)，尝试从全局队列中获取goroutine来运行。
- `为什么是61？`:这是一个经验值，目的是在减少全局队列锁竞争和保证公平性之间取得平衡。频繁检查全局队列会带来锁竞争开销，完全忽略全局队列会导致全局饥饿。
### 全局队列检查
- 当满足`61`次调度周期时，调度器会调用全局队列，尝试从全局队列中批量获取最多`1/2*全局队列长度`的goroutine到当前P的本地队列。
- 全局队列的角色: 
	1.通过`go`关键字创建且无法放入本地队列的goroutine(例如本地队列已满时，会放一半到全局队列)。
	2.从网络轮询器就绪的goroutine（例如：I/O完成唤醒的goroutine
	3.长时间未被调度的goroutine
### work-stealing机制
如果经过上述步骤后，当前P的本地队列仍然没有可运行的goroutine，调度器会进入work-stealing阶段:
- 偷取其他P的本地队列：
	随机选择一个其他P，从其本地队列尾部偷取一半的goroutine(分摊任务，避免一次性全部偷走导致负载不平衡)
- 检查网络轮询器
	如果仍然没有任务，检查是否有网络时间就绪的goroutine、
- 从全局队列再次偷取
	如果所有尝试都失败，最终会再次检查全局队列(可能其他P在此期间放入了任务)
### 设计目标
- 公平性:通过定期检查全局队列，确保全局队列中的goroutine不会完全饥饿
- 负载均衡:通过work-stealing机制，平衡不同P之间的负载，避免某些P空闲而其他P过载。
- 低延迟:减少全局队列的锁竞争(通过批量偷取和周期性检查)，同时优先利用本地队列的高效无锁操作
