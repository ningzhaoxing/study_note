# 基本应用
## 阻塞与非阻塞式的收发
### 阻塞式收发
`select`控制结构中，若不包含`default`语句，那么会有两种情况：
1. 存在可收发的`channel`，执行该`channel`的`case`
2. 不存在可收发的`channel`, 阻塞
### 非阻塞式收发
`select`控制结构中，若包含`default`语句，那么会有两种情况：
1. 存在可收发的`channel`，执行该`channel`的`case`
2. 不存在可收发的`channel`, 执行`default`对应的语句
## 随机执行
如果有多个`channel`同时满足可收发，那么会随机执行其中一个`channel`所对应的`case`语句。
```go
func main() {
	ch := make(chan int)
	go func() {
		for range time.Tick(1 * time.Second) {
			ch <- 0
		}
	}()

	for {
		select {
		case <-ch:
			println("case1")
		case <-ch:
			println("case2")
		}
	}
}
```

# 底层实现
## 数据结构
`select`不存在对应的结构体。
但是可以用`runtime.scase`结构体表示`select`控制结构中的`case`:
```go
type scase struct {
	c    *hchan         // chan
	elem unsafe.Pointer // data element
}
```

## 实现原理
`select` 语句在编译期间会被转换成 `OSELECT` 节点。每个 `OSELECT` 节点都会持有一组 `OCASE` 节点。
如果 `OCASE` 的执行条件是空，那就意味着这是一个 `default` 节点。
![](Pasted%20image%2020250219204517.png)

`select`执行的四种情况:
### 1. `select`不存在任何`case`
结果：直接阻塞
执行的代码如下：
```go
func block() {
	gopark(nil, nil, waitReasonSelectNoCases, traceEvGoStop, 1)
}
```
意思就是，让当前`goroutine`进入无法被唤醒的永久休眠状态。

### 2. 包含一个`case`
编译器会讲`select`改写成`if`条件语句。
```go
// 改写前
select {
case v, ok <-ch: // case ch <- v
    ...    
}

// 改写后
if ch == nil {
    block()
}
v, ok := <-ch // case ch <- v
...
``````

### 3. 一个`case`一个`default`
当 `select` 中仅包含两个 `case`，并且其中一个是 `default` 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。

编译器对***非阻塞式发送***和***非阻塞式接收***进行不同的优化。

#### 非阻塞式发送
执行代码：
```go
select {
case ch <- i:
    ...
default:
    ...
}

if selectnbsend(ch, i) {
    ...
} else {
    ...
}
```

`selectnbsend()` 函数提供了向`channel`非阻塞地发送数据地能力。
如果无法向当前`channel`发送数据，则会执行`default`。

#### 非阻塞式接收
执行代码：
```go
// 改写前
select {
case v <- ch: // case v, ok <- ch:
    ......
default:
    ......
}

// 改写后
if selectnbrecv(&v, ch) { // if selectnbrecv2(&v, &ok, ch) {
    ...
} else {
    ...
}
```

根据返回值数量的不同，会执行不同的***非阻塞接收的函数***，`selectnbrecv()`或`selectnbrecv2()`。
这两个函数的实现如下：
```go
func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) {
	selected, _ = chanrecv(c, elem, false)
	return
}

func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) {
	selected, *received = chanrecv(c, elem, false)
	return
}
```

### 2个及以上case
这种情况就是正常流程：
1. 将所有的 `case` 转换成包含 Channel 以及类型等信息的 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体；
2. 调用运行时函数 [`runtime.selectgo`](https://draveness.me/golang/tree/runtime.selectgo) 从多个准备就绪的 Channel 中选择一个可执行的 [`runtime.scase`](https://draveness.me/golang/tree/runtime.scase) 结构体；
3. 通过 `for` 循环生成一组 `if` 语句，在语句中判断自己是不是被选中的 `case`；

实现源码如下：
```go
selv := [3]scase{}
order := [6]uint16
for i, cas := range cases {
    c := scase{}
    c.kind = ...
    c.elem = ...
    c.c = ...
}
chosen, revcOK := selectgo(selv, order, 3)
if chosen == 0 {
    ...
    break
}
if chosen == 1 {
    ...
    break
}
if chosen == 2 {
    ...
    break
}
```

`selectgo()`函数的执行过程：
1. 执行初始化操作并确定`case`处理顺序
2. 在循环中根据`case`的类型做不同处理
#### 初始化
首先会进行执行必要的初始化操作并决定处理 `case` 的两个顺序 — 轮询顺序 `pollOrder` 和加锁顺序 `lockOrder`：
底层源码实现：
```go
func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) {
	cas1 := (*[1 << 16]scase)(unsafe.Pointer(cas0))
	order1 := (*[1 << 17]uint16)(unsafe.Pointer(order0))
	
	ncases := nsends + nrecvs
	scases := cas1[:ncases:ncases]
	pollorder := order1[:ncases:ncases]
	lockorder := order1[ncases:][:ncases:ncases]

	norder := 0
	for i := range scases {
		cas := &scases[i]
	}

	for i := 1; i < ncases; i++ {
		j := fastrandn(uint32(i + 1))
		pollorder[norder] = pollorder[j]
		pollorder[j] = uint16(i)
		norder++
	}
	pollorder = pollorder[:norder]
	lockorder = lockorder[:norder]

	// 根据 Channel 的地址排序确定加锁顺序
	...
	sellock(scases, lockorder)
	...
}
```
轮询顺序 `pollOrder` 和加锁顺序 `lockOrder` 分别是通过以下的方式确认的：
- 轮询顺序：通过 [`runtime.fastrandn`](https://draveness.me/golang/tree/runtime.fastrandn) 函数引入随机性；
- 加锁顺序：按照 Channel 的地址排序后确定加锁顺序；
