# 底层实现

我们可以先讲讲go语言map的底层实现，首先它的底层结构体是一个叫`hmap`的结构体，其底层实现就是哈希表。
其中维护了一些buckets数组，也就是桶。其中桶也分为*当前桶*和*旧桶*，其对应的也有溢出桶，一个桶最多存8个键值对，当一个桶满了时，又来了一个键值对到该桶，这时就需要用到*溢出桶*。

#### 然后，map是如何将键值对存储到桶中呢？
`hmap`结构体中的buckets实际上是一个`unsafe.Pointer`，用来记录桶的地址。
其指向的是一个叫`bmap`的结构体，其中会存哈希值的高8位，以及键值对，还有溢出桶的地址。

map会通过哈希函数计算出key的哈希值，取**哈希值的低B位**确定桶位置，然后再通过**高八位**将键值对存储到桶中不同的位置。

包括在进行查找的时候，也是根据哈希值的低八位和高八位去查询。

#### 然后，因为底层实现是哈希表，所以是会存在哈希冲突的

哈希冲突就是可能会存在两个不同的键经过哈希计算的哈希值是相同的，导致存的位置发生冲突，这个时候我们就需要解决这个问题。

go语言的map通过 *负载因子* 衡量一个哈希表的冲突情况，一般负载因子越小，则说明空间利用率低，过大则说明冲突严重，这时会进行refresh或者扩容。

一般存在两种解决方案：
一是拉链法，也就是go语言实现的溢出桶，当然溢出桶过多时，就会降低查询效率，这时就需要进行扩容。

二是开放寻址法，通过探测下一个空闲的哈希地址来存放冲突元素，具体的实现方式可以是线性探测或者二次探测。

#### 然后gomap是如何扩容的呢？

gomap在每次添加元素时，都会检查是否需要扩容，需要扩容的条件有两个：
一是负载因子大于6.5时，
二是，溢出桶太多。在负载因子较小的情况下，也可能会出现map查找和插入效率很低的情况，因为负载因子的计算公式是 *key的数量/bucket数量*，不断的增删会导致溢出桶过多。

gomap的扩容是渐进式的，当满足扩容条件时，就会创建一个新的buckets，新的buckets长度为原来的两倍，然后go会逐步搬迁旧buckets的键值对，每次访问都会触发一次搬迁。

这个时候，buckets就指向当前的buckets，而oldbuckets就指向旧的buckets，直到oldbuckets的所有键值对都搬迁过来，就删除oldbuckets，其实就是设置为nil。

## 扩容

### 等量扩容
这个桶在不断的增删过程中，桶中会出现很多断断续续的位置，会导致bmap的溢出桶很长，等量扩容实际上就是一种`refresh`，对元素进行重新排列，使得元素与元素之间更加紧凑，提高查询效率。

### 2倍扩容
当桶确实不够用的时候，则会触发2倍扩容，将oldbuckets中的元素逐步迁移到buckets。每次进行增删操作的时候，都会迁移一部分元素。
在扩容没有完全迁移之前，每次遍历查询数据时，会先遍历oldbuckets，然后遍历buckets

# Sync.Map与加锁map的区别
## Sync.Map
它是一种轻量级的并发安全映射，适用于读写操作都比较频繁的场景。














