# ziplist
当元素数量较少的时候，zset会使用ziplist来实现

# skiplist
元素数量超过128个时，采用skiplist实现。

skiplist实现了在有序链表中的logn复杂度的效率进行增删查。思路类似于对有序链表进行二分查找，但是因为链表无法像数组那样可以随机访问，所以调表为结点设置了快速访问的指针。
通过这个指针快速跳跃来达到类似二分法的效果。

## 高度的计算
执行插入操作时，会有一个计算随机数的过程来决定当前结点的高度。
计算过程如下：
- 首先，每个结点都有第一层指针
- 如果一个结点有第i层指针，那么它有第(i+1)层指针的概率为p
- 结点的最大层数不允许超过一个最大值，记为MaxLevel
随机数计算伪码如下：
```go
randomLevel()
level:=1
for random() < p && level < MaxLevel {
	level ++
}
return level
```
	p = 1/4    MaxLevel=32

# 与平衡树(AVL、红黑树)、哈希表的比较
与平衡树比较：
查询时间复杂度都为O(logn)，但范围查找(需要做中序遍历)、插入(调整子树结构)等操作比较复杂。

与哈希表比较：
虽然哈希表的查询时间复杂度为O(1)，但是它不支持范围查找。

# 为什么要使用随机概率决定结点高度
可以假设，如果不随机概率地去决定结点高度的话，就类似于平衡树一样，相邻层的结点个数控制在2:1的对应关系，要维持这种关系在插入删除操作时，就需要对被操作结点之后的所有结点进行重新调整，这会让时间复杂度重新退化为O(n)。