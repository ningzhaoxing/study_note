# 旁路缓存
流程：
- 读：
	先读缓存，命中则返回；否则读数据库，并存入缓存
- 写：
	先更新数据库，再删除缓存
优点：
1. 实现简单，适合读多写少场景
缺点：
2. 首次请求的数据一定不存在缓存(热点key提前写入缓存)
3. 写操作频繁导致缓存被频繁删除，影响命中率
4. 容易造成缓存击穿
# 读写穿透
流程：
- 读：
	先读缓存，命中则返回；否则读数据库，并存入缓存
- 写：
	先查缓存，若缓存中不存在，则更新数据库。若缓存中存在，则先更新缓存再更新数据库

优点：
- 一致性高
缺点：
- 实现复杂
- 写操作延迟

# 异步写入
写操作时更新缓存时，异步更新数据库。

优点：
1. 写性能高
缺点：
2. 短暂的不一致性性
3. 需要重试或日志恢复等机制保证数据最终一致性

# 缓存一致性问题
## 读写穿透
先更新数据库还是先更新缓存
在并发情况下，两个请求同时到达，无法保证两个请求更新数据库和缓存的顺序，因此可能会导致数据不一致的情况。
所以，无论是先更新数据库还是先更新缓存都会存在数据不一致问题。

## 先删缓存再更新数据库
一个线程先删除缓存，数据库还没更新成功，此时另一个线程读到旧数据，并写回到缓存。此时就出现了缓存不一致情况。

解决方案：
使用延迟双删。

## 先更新数据库再删缓存
如果更新数据库后，删除缓存失败，另一个线程则会读到脏数据。

## 异步写入
写操作先更新缓存，异步更新到数据库。
