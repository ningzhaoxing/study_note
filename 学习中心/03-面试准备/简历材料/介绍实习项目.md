# 1. 项目介绍

“我先简单介绍一下项目背景和核心概念，方便后面理解我做的模型演进部分：
飞书集成平台是一个低代码的集成系统，用户可以通过工作流的方式把不同系统连接起来，实现业务流程自动化。  
我主要负责的是工作流的第一个节点——**触发器** 的设计演进。
触发器目前分为两个版本：
- **G1 版本**是线上版本，用 Go 全代码实现，每个外部系统都需要单独开发，比如 Gmail、Outlook；
- **G2 版本**是我们正在开发的新版本，希望通过一次通用的模型设计和配置化方式，就能快速支持不同外部系统。
另外，触发器内部有两种消费模型：
- 一种是**轮询触发器（pull 模式）**，定时去外部系统拉取事件；
- 另一种是**即时触发器（push 模式）**，由外部系统主动推送事件给我们。

项目背景和核心概念讲完了，您看还有什么不懂的，我补充一下。


# 2. 方案设计

我负责的就是在这个 G2 版本中，对触发器的模型进行一次演进。
当时我们遇到一个挺典型的问题：像 Gmai[[学习中心/03-面试准备/简历材料/自我介绍]]l、Outlook 这样的外部系统，在推送或拉取事件时，只返回事件的 **ID**，而不是完整的事件实体。  
但我们现有的触发器模型默认是直接处理完整实体的，这样模型语义就对不上。

问题就在于如何优雅地设计来补全实体？
我当时就在想：这个 “ID → 实体” 的获取过程，到底应该是谁的职责？是放在触发器里，还是抽离出来？

所以我设计了两个方案：
- 一种是改造原有的 **DataFetcher**，通过策略模式支持“两段式拉取”——先拿元数据，再拿实体；
- 另一种是新增一个独立的 **DataEnricher（数据丰富器）**，专门负责把 ID 补全为实体，不去侵入原模型。

前者的优点是复用现有语义，但要修改核心模型；  
后者的好处是模型职责更清晰，对原代码无侵入。

在评审过程中我还提出，其实 push 模型也存在相同的问题，所以这个 **DataEnricher** 可以设计成通用组件，用于统一解决 pull 和 push 两种触发器的事件补全逻辑。

最终我们选择了第二种方案，在领域层新增 DataEnricher，解耦了触发器与外部系统的事件结构。  
这样不仅解决了 Gmail、Outlook 的兼容问题，也让后续扩展新的外部系统变得更简单。

这次经历对我来说收获很大，因为我第一次从模型语义和职责边界的角度去思考问题，也更理解了在设计中如何平衡**模型纯洁性**和**可复用性**。”
