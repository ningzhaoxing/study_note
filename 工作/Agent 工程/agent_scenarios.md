# Agent 场景需求文档

> 本文档系统梳理了资产识别 Agent 和损害场景 Agent 需要支持的所有场景，用于指导架构设计和优化。
>
> **文档版本**: v1.0
> **创建日期**: 2026-02-10
> **维护者**: Architecture Team

---

## 目录

- [一、资产识别 Agent 场景](#一资产识别-agent-场景)
  - [1.1 基础识别场景](#11-基础识别场景)
  - [1.2 重试场景](#12-重试场景)
  - [1.3 咨询场景](#13-咨询场景)
  - [1.4 边界场景](#14-边界场景)
- [二、损害场景 Agent 场景](#二损害场景-agent-场景)
  - [2.1 基础生成场景](#21-基础生成场景)
  - [2.2 CAL 分析场景](#22-cal-分析场景)
  - [2.3 重试场景](#23-重试场景)
  - [2.4 咨询场景](#24-咨询场景)
  - [2.5 组合意图场景](#25-组合意图场景)
  - [2.6 边界场景](#26-边界场景)
- [三、跨场景的通用需求](#三跨场景的通用需求)
  - [3.1 会话管理](#31-会话管理)
  - [3.2 实时反馈](#32-实时反馈)
  - [3.3 错误处理](#33-错误处理)
- [四、场景复杂度分析](#四场景复杂度分析)
- [五、架构设计决策点](#五架构设计决策点)

---

## 一、资产识别 Agent 场景

### 1.1 基础识别场景

#### 场景 A1：首次识别（全新资产）

**场景描述**：用户选中的资产都没有安全属性数据，首次进行识别。

**用户操作**：
- 在前端选中 5 个资产
- 点击"开始识别"按钮

**系统状态**：
- 这 5 个资产在数据库中都没有安全属性数据
- 数据状态类型：`all_new`

**用户消息**：
- 空字符串（只点击按钮）
- "开始识别"
- "识别这些资产"
- "帮我识别一下"

**期望行为**：
1. ✅ 直接执行识别，无需确认
2. ✅ 发送 `session_start` 事件
3. ✅ 逐个识别资产，发送进度事件
4. ✅ 完成后发送 `complete` 事件

**技术要点**：
- Handler 层检测到 `all_new` 状态，直接调用 `Agent.BatchIdentifySecurityProperties()`
- 无需意图识别（明确的执行意图）
- 无需确认流程

**测试用例**：
```
输入：selectedAssets=["COMP-1", "COMP-2", "COMP-3"], userMessage=""
数据状态：all_new
期望：直接识别，返回 3 个资产的安全属性
```

---

#### 场景 A2：全部已识别（覆盖场景）

**场景描述**：用户选中的资产都已有安全属性数据，需要确认是否覆盖。

**用户操作**：
- 在前端选中 5 个资产（都已识别过）
- 点击"开始识别"按钮

**系统状态**：
- 这 5 个资产在数据库中都已有安全属性数据
- 数据状态类型：`all_existing`

**用户消息**：
- 空字符串
- "重新识别"
- "再识别一次"

**期望行为**：
1. ⚠️ 发送确认询问："这些资产已有安全属性数据，是否重新识别（覆盖）？"
2. ⏸️ 暂停执行，等待用户回复
3. 用户回复后：
   - "确认" / "是" / "好的" → 执行覆盖识别
   - "取消" / "不用" / "算了" → 取消操作

**技术要点**：
- Handler 层检测到 `all_existing` 状态
- 调用 `sendConfirmationInquiry()` 发送询问
- 保存会话状态（待确认的资产列表）
- 下次请求时，解析用户回复

**测试用例**：
```
第 1 次请求：
  输入：selectedAssets=["COMP-1", "COMP-2"], userMessage=""
  数据状态：all_existing
  期望：返回确认询问消息

第 2 次请求：
  输入：userMessage="确认"
  期望：执行覆盖识别
```

---

#### 场景 A3：部分已识别（混合场景）

**场景描述**：用户选中的资产中，部分已有数据，部分没有数据。

**用户操作**：
- 在前端选中 5 个资产
- 点击"开始识别"按钮

**系统状态**：
- 3 个资产已有安全属性数据
- 2 个资产没有安全属性数据
- 数据状态类型：`mixed`

**用户消息**：
- 空字符串
- "识别资产"

**期望行为**：
1. ⚠️ 发送确认询问："部分资产已有数据，请选择处理方式："
   - 选项 1："只处理新的（2 个）"
   - 选项 2："全部处理（5 个，覆盖已有数据）"
   - 选项 3："取消"
2. ⏸️ 暂停执行，等待用户回复
3. 用户回复后：
   - "只处理新的" → 只识别 2 个新资产
   - "全部处理" / "覆盖" → 识别全部 5 个资产
   - "取消" → 取消操作

**技术要点**：
- Handler 层检测到 `mixed` 状态
- 调用 `sendConfirmationInquiry()` 发送询问（包含选项）
- 保存会话状态（新资产列表 + 全部资产列表）
- 下次请求时，根据用户回复选择资产列表

**测试用例**：
```
第 1 次请求：
  输入：selectedAssets=["COMP-1", "COMP-2", "COMP-3", "COMP-4", "COMP-5"]
  数据状态：mixed (COMP-1,2,3 已有数据，COMP-4,5 没有)
  期望：返回确认询问消息（包含选项）

第 2 次请求（选项 1）：
  输入：userMessage="只处理新的"
  期望：只识别 COMP-4, COMP-5

第 2 次请求（选项 2）：
  输入：userMessage="全部处理"
  期望：识别全部 5 个资产
```

---

#### 场景 A4：明确指令（跳过确认）

**场景描述**：用户通过明确的指令表达了处理意图，无需确认。

**用户操作**：
- 在前端选中 5 个资产（3 个已有数据，2 个没有）
- 输入明确的指令

**系统状态**：
- 数据状态类型：`mixed`

**用户消息**：
- "只处理新的"
- "只识别新资产"
- "跳过已有的"
- "全部重新生成"
- "覆盖所有"
- "全部处理"

**期望行为**：
1. ✅ 根据指令直接执行，无需确认
2. "只处理新的" → 识别 2 个新资产
3. "全部重新生成" → 识别全部 5 个资产（覆盖）

**技术要点**：
- Handler 层使用 `parseUserIntent()` 快速路由
- 检测到明确指令后，设置 `userIntent`
- 调用 `decideRouting()` 决定资产列表
- 直接执行，跳过确认流程

**测试用例**：
```
输入：selectedAssets=["COMP-1", "COMP-2", "COMP-3"], userMessage="只处理新的"
数据状态：mixed (COMP-1 已有数据，COMP-2,3 没有)
期望：直接识别 COMP-2, COMP-3（无确认）
```

---

### 1.2 重试场景

#### 场景 B1：重试失败资产

**场景描述**：上次识别时部分资产失败，用户希望重试失败的资产。

**前置条件**：
- 上次识别时，5 个资产中有 2 个失败（如 LLM 超时）
- 失败资产已记录到 `RetryManager`（会话级别）

**用户操作**：
- 不选择任何资产（或选择无关资产）
- 输入重试指令

**用户消息**：
- "重试失败的"
- "重试"
- "retry"
- "再试一次失败的"

**期望行为**：
1. ✅ 从 `RetryManager` 加载失败的 2 个资产
2. ✅ 直接识别，无需确认（因为用户明确表达了重试意图）
3. ✅ 识别成功后，从 `RetryManager` 中移除
4. ✅ 如果再次失败，保留在 `RetryManager` 中

**技术要点**：
- Handler 层使用 `detectRetryIntent()` 检测重试意图
- 调用 `retryManager.GetFailedAssets()` 加载失败资产
- 设置 `userMessageForAgent = ""` （避免 Agent 误解）
- 直接调用 `Agent.BatchIdentifySecurityProperties()`

**测试用例**：
```
前置条件：RetryManager 中有 ["COMP-3", "COMP-5"]
输入：selectedAssets=[], userMessage="重试"
期望：识别 COMP-3, COMP-5
```

---

#### 场景 B2：重试时无失败资产

**场景描述**：用户输入重试指令，但没有失败的资产。

**前置条件**：
- 上次识别全部成功，`RetryManager` 为空

**用户消息**：
- "重试"

**期望行为**：
1. ✅ 提示用户："没有失败的资产需要重试，上次识别已全部成功。"
2. ✅ 不执行任何识别操作

**技术要点**：
- Handler 层检测到重试意图
- 调用 `retryManager.GetFailedAssets()` 返回空列表
- 发送提示消息，结束流程

**测试用例**：
```
前置条件：RetryManager 为空
输入：userMessage="重试"
期望：返回提示消息"没有失败的资产需要重试"
```

---

### 1.3 咨询场景

#### 场景 C1：查询类问题

**场景描述**：用户查询特定资产的安全属性。

**用户操作**：
- 可能选中资产，也可能不选
- 输入查询问题

**用户消息**：
- "COMP-1 的安全属性是什么？"
- "查看 COMP-2 的机密性"
- "COMP-3 有哪些安全属性？"

**期望行为**：
1. ✅ 识别为咨询意图（不执行识别）
2. ✅ 查询数据库，获取资产的安全属性数据
3. ✅ 返回答案（包含推理过程）

**技术要点**：
- Handler 层使用 `analyzeUserIntentWithContext()` 识别为 `consultation`
- 调用 `Agent.StreamWithIntent()` 进行咨询
- Agent 内部调用 `query_asset_security_properties` 工具
- 返回结构化答案

**测试用例**：
```
输入：userMessage="COMP-1 的机密性是什么？"
期望：返回 "COMP-1 的机密性为 High，推理过程：..."
```

---

#### 场景 C2：统计类问题

**场景描述**：用户查询统计信息。

**用户消息**：
- "有多少个资产已经识别了？"
- "识别了几个资产？"
- "还有多少个资产没识别？"

**期望行为**：
1. ✅ 识别为咨询意图
2. ✅ 查询数据库统计数据
3. ✅ 返回统计结果

**技术要点**：
- 可以在 Handler 层直接查询（`buildDataDrivenConsultationAnswer`）
- 避免调用 Agent，减少成本

**测试用例**：
```
输入：userMessage="有多少个资产已经识别了？"
期望：返回 "当前项目已识别 15 个资产"
```

---

#### 场景 C3：解释类问题

**场景描述**：用户询问识别结果的推理过程。

**用户消息**：
- "为什么 COMP-1 的机密性是 High？"
- "COMP-2 的完整性为什么是 Medium？"
- "解释一下 COMP-3 的安全属性"

**期望行为**：
1. ✅ 识别为咨询意图
2. ✅ 查询识别结果（包含推理过程）
3. ✅ 返回解释

**技术要点**：
- 调用 `Agent.StreamWithIntent()` 进行咨询
- Agent 调用 `query_asset_security_properties` 工具
- 返回推理过程

---

#### 场景 C4：能力咨询

**场景描述**：用户询问 Agent 的功能和使用方法。

**用户消息**：
- "你能做什么？"
- "如何使用？"
- "有哪些功能？"

**期望行为**：
1. ✅ 识别为咨询意图
2. ✅ 返回功能介绍和使用指南

---

### 1.4 边界场景

#### 场景 D1：未选择资产

**场景描述**：用户没有选择任何资产就点击识别。

**用户操作**：
- 不选择任何资产
- 点击"开始识别"或输入"识别资产"

**用户消息**：
- "开始识别"
- "识别资产"

**期望行为**：
1. ⚠️ 提示用户："请先选择要识别的资产"
2. ✅ 不执行任何识别操作

**技术要点**：
- Handler 层检查 `selectedAssets` 是否为空
- 如果为空且不是重试/咨询意图，返回提示

---

#### 场景 D2：选择了无效资产

**场景描述**：用户选中的资产 ID 在数据库中不存在。

**用户操作**：
- 选中资产 ID："COMP-999"（不存在）

**期望行为**：
1. ⚠️ 提示用户："资产 COMP-999 不存在，请检查"
2. ✅ 不执行识别操作

**技术要点**：
- Handler 层调用 `prepareSelectedAssets()` 时查询数据库
- 如果资产不存在，返回错误

---

#### 场景 D3：确认时追问

**场景描述**：系统正在等待用户确认，用户追问相关问题。

**系统状态**：
- 正在等待用户确认是否覆盖

**用户消息**：
- "为什么需要覆盖？"
- "覆盖会怎样？"
- "覆盖会丢失数据吗？"

**期望行为**：
1. ✅ 回答用户的问题
2. ✅ 保持确认状态，继续等待用户决策
3. ✅ 提示用户："请回复'确认'或'取消'"

**技术要点**：
- Handler 层检测到会话状态为 `waiting_confirmation`
- 识别用户消息为追问（不是确认/取消）
- 调用 Agent 回答问题
- 保持会话状态不变

---

#### 场景 D4：中途取消

**场景描述**：识别过程中，用户点击停止按钮。

**系统状态**：
- 正在识别 5 个资产，已完成 2 个

**用户操作**：
- 点击"停止"按钮

**期望行为**：
1. ✅ 立即停止 Agent 执行
2. ✅ 保存已成功的 2 个资产结果
3. ✅ 记录未完成的 3 个资产到 `RetryManager`
4. ✅ 发送停止消息

**技术要点**：
- 前端调用 `/stop` 接口
- Handler 层发送停止信号到 `session.StopChan`
- Agent 检测到 `ctx.Done()`，立即停止
- 清理资源，释放任务锁

---

## 三、跨场景的通用需求

### 3.1 会话管理

#### 场景 K1：多轮对话记忆

**场景描述**：Agent 需要记住上一轮的上下文。

**示例**：
```
第 1 轮：用户："识别 COMP-1 的安全属性"
第 2 轮：用户："它的机密性为什么是 High？"
```

**期望行为**：
- ✅ Agent 记得"它"指的是 COMP-1

**技术要点**：
- 使用 Memory 组件保存对话历史
- 使用 Persister 持久化到数据库

---

#### 场景 K2：跨请求状态保持

**场景描述**：确认流程需要跨请求保持状态。

**示例**：
```
第 1 次请求：系统询问"是否覆盖？"
第 2 次请求：用户回复"确认"
```

**期望行为**：
- ✅ 系统记得上次的询问，继续执行覆盖操作

**技术要点**：
- Handler 层管理会话状态
- 使用状态机模式

---

### 3.2 实时反馈

#### 场景 L1：进度反馈

**场景描述**：批量处理时，实时反馈进度。

**期望行为**：
- ✅ 发送 SSE 事件：
  - "正在识别 COMP-1..."
  - "COMP-1 识别完成"
  - "已完成 2/10"

**技术要点**：
- 使用 SSE（Server-Sent Events）
- 使用 EventEmitter 发送事件

---

#### 场景 L2：工具调用反馈

**场景描述**：Agent 调用工具时，实时反馈。

**期望行为**：
- ✅ 发送 SSE 事件：
  - "🔍 查找未处理目标"
  - "📊 检查数据状态"
  - "⚡ 生成损害场景"

**技术要点**：
- 使用 Callback Handler 捕获工具调用
- 发送 `tool_call` 和 `tool_result` 事件

---

### 3.3 错误处理

#### 场景 M1：单个资产失败

**场景描述**：批量处理时，单个资产失败，继续处理剩余资产。

**系统状态**：
- 识别 5 个资产，第 3 个失败（LLM 超时）

**期望行为**：
1. ✅ 继续处理剩余资产
2. ✅ 记录失败资产到 RetryManager
3. ✅ 最终报告"成功 4 个，失败 1 个"

**技术要点**：
- Agent 内部捕获单个资产的错误
- 不中断整个流程

---

#### 场景 M2：全部失败

**场景描述**：LLM 服务不可用，全部失败。

**期望行为**：
1. ✅ 立即停止
2. ⚠️ 提示"AI 服务暂时不可用，请稍后重试"

---

#### 场景 M3：客户端断开

**场景描述**：用户关闭浏览器，客户端断开连接。

**期望行为**：
1. ✅ 检测到连接断开
2. ✅ 立即停止 Agent 执行
3. ✅ 清理资源

**技术要点**：
- 监听 HTTP 请求的 context
- 检测 `ctx.Done()`

---

## 四、场景复杂度分析

### 4.1 按复杂度分类

#### 简单场景（规则可处理）- 80%

**特点**：
- ✅ 关键词明确
- ✅ 逻辑简单
- ✅ 无需深度理解

**场景列表**：
1. 明确指令："开始识别"、"重试"、"取消"、"只处理新的"
2. 数据状态判断：全新、全部已有、混合
3. 快速查询："有多少个资产"、"COMP-1 的 CAL 是什么"

**处理策略**：
- Handler 层规则匹配（零成本）
- 简单查询直接查库（避免 Agent）

---

#### 中等场景（需要 LLM 辅助）- 15%

**特点**：
- 🔶 需要语义理解
- 🔶 需要上下文推理
- 🔶 可能需要多轮交互

**场景列表**：
1. 模糊指令："帮我处理一下"、"分析这些资产"
2. 解释类问题："为什么是 High？"
3. 上下文依赖："它的机密性是什么？"（需要记住"它"指什么）

**处理策略**：
- Handler 层快速路由失败后，交给 Agent
- Agent 使用 LLM 理解意图

---

#### 复杂场景（需要 Agent 自主决策）- 5%

**特点**：
- ❌ 多步骤执行
- ❌ 需要规划
- ❌ 需要错误处理

**场景列表**：
1. 组合意图："先生成再分析"
2. 边咨询边执行："生成 COMP-1 的损害场景，顺便告诉我它的安全属性"
3. 动态调整："如果失败就重试 3 次"

**处理策略**：
- 完全交给 Agent 自主决策
- Agent 使用 ReAct 模式多轮推理

---

### 4.2 按频率分类

#### 高频场景（80%）

1. **首次识别（全新资产）** - 40%
   - 用户最常见的操作
   - 直接执行，无需确认

2. **重试失败资产** - 15%
   - 失败后的常见操作
   - 直接执行，无需确认

3. **简单咨询（查询数据）** - 15%
   - "COMP-1 的安全属性是什么？"
   - 直接查库，无需 Agent

4. **明确指令（"只处理新的"）** - 10%
   - 用户明确表达意图
   - 快速路由，无需确认

---

#### 中频场景（15%）

1. **覆盖确认（全部已有数据）** - 5%
   - 需要确认流程
   - 跨请求状态管理

2. **混合状态确认（部分已有）** - 5%
   - 需要确认流程
   - 提供选项

3. **解释类问题** - 3%
   - "为什么是 High？"
   - 需要 Agent 推理

4. **中途取消** - 2%
   - 用户主动停止
   - 需要清理资源

---

#### 低频场景（5%）

1. **组合意图** - 2%
   - "先生成再分析"
   - 需要 Agent 规划

2. **确认时追问** - 1%
   - "为什么需要覆盖？"
   - 需要保持状态

3. **超出能力范围** - 1%
   - "删除所有数据"
   - 需要拒绝

4. **边界异常** - 1%
   - 无效 ID、无数据等
   - 需要友好提示

---

## 五、架构设计决策点

基于以上场景分析，我们需要回答以下关键问题：

### 决策点 1：意图识别在哪一层？

#### 选项 A：Handler 层

**适合场景**：
- ✅ 高频简单场景（80%）
- ✅ 明确指令："开始识别"、"重试"、"取消"

**优势**：
- ✅ 快速路由，零成本
- ✅ 响应速度快（毫秒级）
- ✅ 行为可控，易于调试

**劣势**：
- ❌ 复杂场景难处理
- ❌ 需要维护大量规则

---

#### 选项 B：Agent 层

**适合场景**：
- ✅ 中低频复杂场景（20%）
- ✅ 模糊指令、组合意图

**优势**：
- ✅ 灵活，智能
- ✅ 易于扩展

**劣势**：
- ❌ 每次都调用 LLM，成本高
- ❌ 响应延迟（1-3 秒）

---

#### 推荐：混合策略

```
Handler 层：快速路由（80% 高频场景）
  ├─ 规则匹配："重试" → 加载失败资产
  ├─ 规则匹配："取消" → 返回取消消息
  ├─ 规则匹配："只处理新的" → 过滤资产
  └─ 无法匹配 ↓
Agent 层：智能决策（20% 复杂场景）
  └─ LLM 理解意图 → 调用工具 → 返回结果
```

---

### 决策点 2：确认流程在哪一层？

#### 选项 A：Handler 层 ✅ 推荐

**理由**：
- ✅ 确认流程涉及"暂停-等待-继续"
- ✅ 需要跨请求状态管理
- ✅ Handler 层管理会话状态更自然

**实现方式**：
```go
// 第 1 次请求
if dataStatus == "all_existing" {
    sendConfirmationInquiry(...)
    saveSessionState(session, assets)
    return
}

// 第 2 次请求
if sessionState == "waiting_confirmation" {
    decision := parseUserReply(userMessage)
    if decision.Confirm {
        agent.BatchIdentify(...)
    }
}
```

---

#### 选项 B：Agent 层

**理由**：
- ❌ Agent 通常是单次执行
- ❌ 跨请求状态难管理
- ❌ 需要外部状态存储

---

### 决策点 3：重试逻辑在哪一层？

#### 推荐：分层处理

**Handler 层：会话级别重试**
- ✅ 用户主动重试（"重试失败的"）
- ✅ 从 RetryManager 加载失败资产
- ✅ 业务逻辑清晰

**Agent 层：执行级别重试**
- ✅ LLM 超时自动重试（3 次）
- ✅ 网络错误自动重试
- ✅ 技术层面的容错

---

### 决策点 4：数据查询在哪一层？

#### 推荐：分层处理

**Handler 层：简单统计查询**
- ✅ "有多少个资产？" → `COUNT(*)`
- ✅ "COMP-1 的 CAL？" → `SELECT * WHERE asset_id`
- ✅ 直接查库，快速返回
- ✅ 零 LLM 调用（成本优化）

**Agent 层：需要推理的查询**
- ✅ "为什么是 High？" → 需要解释推理过程
- ✅ "比较 COMP-1 和 COMP-2" → 需要分析对比
- ✅ Agent 调用工具查询 + LLM 推理

---

## 六、优化后的架构设计

基于以上场景分析和决策点，推荐以下架构：

```
┌─────────────────────────────────────────────────────────┐
│ Handler 层（HTTP + 状态管理 + 快速路由）                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 1. 快速路由（规则匹配，80% 高频场景）                    │
│    ├─ "重试" → 加载失败资产 → Agent.Retry()            │
│    ├─ "取消" → 返回取消消息                             │
│    ├─ "确认" → 继续执行                                 │
│    ├─ "只处理新的" → 过滤资产 → Agent.Identify()       │
│    └─ "全部处理" → 全部资产 → Agent.Identify()         │
│                                                         │
│ 2. 数据状态检查 + 确认流程（状态机）                     │
│    ├─ 检查资产数据状态                                  │
│    ├─ 发送确认询问（如需要）                            │
│    └─ 解析用户回复                                      │
│                                                         │
│ 3. 简单数据查询（直接查库，零 LLM 调用）                 │
│    ├─ "有多少个资产" → COUNT(*)                        │
│    ├─ "COMP-1 的 CAL" → SELECT * WHERE asset_id        │
│    └─ "Top 3 损害场景" → ORDER BY impact LIMIT 3       │
│                                                         │
│ 4. 复杂场景交给 Agent（20% 低频场景）                   │
│    └─ agent.Run(ctx, projectID, userMessage, options)  │
│                                                         │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ Agent 层（AI 决策 + 工具调用 + 多轮推理）                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 1. 理解用户意图（LLM）                                   │
│    ├─ 分析用户消息                                      │
│    ├─ 理解上下文                                        │
│    └─ 决定执行计划                                      │
│                                                         │
│ 2. 调用工具执行任务                                      │
│    ├─ identify_asset_security_properties               │
│    ├─ generate_damage_scenario                         │
│    ├─ analyze_cal                                      │
│    ├─ query_data                                       │
│    └─ answer_question                                  │
│                                                         │
│ 3. 多轮推理（复杂场景）                                  │
│    ├─ 组合意图："先生成再分析"                          │
│    ├─ 边咨询边执行                                      │
│    └─ 动态调整策略                                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 七、场景覆盖度检查表

### 资产识别 Agent

| 场景类别 | 场景数量 | 覆盖率 | 优先级 |
|---------|---------|--------|--------|
| 基础识别 | 4 | 100% | P0 |
| 重试场景 | 2 | 100% | P0 |
| 咨询场景 | 4 | 100% | P1 |
| 边界场景 | 4 | 100% | P2 |

### 损害场景 Agent

| 场景类别 | 场景数量 | 覆盖率 | 优先级 |
|---------|---------|--------|--------|
| 基础生成 | 3 | 100% | P0 |
| CAL 分析 | 2 | 100% | P0 |
| 重试场景 | 2 | 100% | P0 |
| 咨询场景 | 5 | 100% | P1 |
| 组合意图 | 2 | 80% | P2 |
| 边界场景 | 4 | 100% | P2 |

### 通用需求

| 需求类别 | 场景数量 | 覆盖率 | 优先级 |
|---------|---------|--------|--------|
| 会话管理 | 2 | 100% | P0 |
| 实时反馈 | 2 | 100% | P0 |
| 错误处理 | 3 | 100% | P0 |

---

## 八、后续优化方向

### 8.1 短期优化（1-2 周）

1. **简化 Handler 层意图识别**
   - 减少 LLM 调用次数（从 2 次降到 1 次）
   - 优先使用规则匹配

2. **优化确认流程**
   - 使用状态机模式
   - 清晰的状态转换

3. **增强错误处理**
   - 单个资产失败不影响整体
   - 友好的错误提示

---

### 8.2 中期优化（1-2 月）

1. **Agent 统一入口**
   - 简化 Handler 层逻辑
   - Agent 内部自主决策

2. **缓存常见意图**
   - 缓存高频指令的意图识别结果
   - 减少 LLM 调用

3. **增强组合意图支持**
   - "先生成再分析"
   - "边咨询边执行"

---

### 8.3 长期优化（3-6 月）

1. **智能推荐**
   - 根据用户历史行为推荐操作
   - "您可能想要：重试失败的资产"

2. **自动化流程**
   - 失败自动重试（可配置）
   - 生成完成后自动分析 CAL

3. **个性化体验**
   - 记住用户偏好（是否总是覆盖）
   - 自适应确认流程

---

## 九、测试用例优先级

### P0（核心场景，必须测试）

1. 首次识别（全新资产）
2. 覆盖确认（全部已有数据）
3. 混合状态确认（部分已有）
4. 重试失败资产
5. 简单咨询查询
6. 中途取消

### P1（重要场景，应该测试）

1. 明确指令（跳过确认）
2. 解释类问题
3. 统计查询
4. CAL 分析
5. 错误处理

### P2（边界场景，可选测试）

1. 未选择资产
2. 无效资产 ID
3. 确认时追问
4. 组合意图
5. 超出能力范围

---

## 十、文档维护

### 更新记录

| 版本 | 日期 | 更新内容 | 维护者 |
|------|------|---------|--------|
| v1.0 | 2026-02-10 | 初始版本，梳理所有场景 | Architecture Team |

### 反馈渠道

如果发现遗漏的场景或有优化建议，请通过以下方式反馈：
- 提交 Issue
- 发送邮件
- 团队会议讨论

---

**文档结束**
